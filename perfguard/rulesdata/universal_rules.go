// Code generated by "precompile.go". DO NOT EDIT.

package rulesdata

import "github.com/quasilyte/go-ruleguard/ruleguard/ir"

var Universal = &ir.File{
	PkgPath:       "gorules",
	CustomDecls:   []string{},
	BundleImports: []ir.BundleImport{},
	RuleGroups: []ir.RuleGroup{
		{
			Line:        43,
			Name:        "stringsCut",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects use cases for strings.Cut",
			DocBefore:   "email := strings.Split(s, \"@\")[0]",
			DocAfter:    "email, _, _ := strings.Cut(s, \"@\")",
			Rules: []ir.Rule{
				{
					Line:            44,
					SyntaxPatterns:  []ir.PatternString{{Line: 44, Value: "$dst := strings.Split($s, $sep)[0]"}},
					ReportTemplate:  "$$ => $dst, _, _ := strings.Cut($s, $sep)",
					SuggestTemplate: "$dst, _, _ := strings.Cut($s, $sep)",
					WhereExpr: ir.FilterExpr{
						Line:  45,
						Op:    ir.FilterGoVersionGreaterEqThanOp,
						Src:   "m.GoVersion().GreaterEqThan(\"1.18\")",
						Value: "1.18",
					},
				},
				{
					Line:            47,
					SyntaxPatterns:  []ir.PatternString{{Line: 47, Value: "$dst = strings.Split($s, $sep)[0]"}},
					ReportTemplate:  "$$ => $dst, _, _ = strings.Cut($s, $sep)",
					SuggestTemplate: "$dst, _, _ = strings.Cut($s, $sep)",
					WhereExpr: ir.FilterExpr{
						Line:  48,
						Op:    ir.FilterGoVersionGreaterEqThanOp,
						Src:   "m.GoVersion().GreaterEqThan(\"1.18\")",
						Value: "1.18",
					},
				},
			},
		},
		{
			Line:        56,
			Name:        "bytesCut",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects use cases for bytes.Cut",
			DocBefore:   "email := bytes.Split(b, \"@\")[0]",
			DocAfter:    "email, _, _ := bytes.Cut(b, []byte(\"@\"))",
			Rules: []ir.Rule{
				{
					Line:            57,
					SyntaxPatterns:  []ir.PatternString{{Line: 57, Value: "$dst := bytes.Split($b, $sep)[0]"}},
					ReportTemplate:  "$$ => $dst, _, _ := bytes.Cut($b, $sep)",
					SuggestTemplate: "$dst, _, _ := bytes.Cut($b, $sep)",
					WhereExpr: ir.FilterExpr{
						Line:  58,
						Op:    ir.FilterGoVersionGreaterEqThanOp,
						Src:   "m.GoVersion().GreaterEqThan(\"1.18\")",
						Value: "1.18",
					},
				},
				{
					Line:            60,
					SyntaxPatterns:  []ir.PatternString{{Line: 60, Value: "$dst = bytes.Split($b, $sep)[0]"}},
					ReportTemplate:  "$$ => $dst, _, _ = bytes.Cut($b, $sep)",
					SuggestTemplate: "$dst, _, _ = bytes.Cut($b, $sep)",
					WhereExpr: ir.FilterExpr{
						Line:  61,
						Op:    ir.FilterGoVersionGreaterEqThanOp,
						Src:   "m.GoVersion().GreaterEqThan(\"1.18\")",
						Value: "1.18",
					},
				},
			},
		},
		{
			Line:        69,
			Name:        "stringsClone",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects use cases for strings.Clone",
			DocBefore:   "s2 := string([]byte(s1))",
			DocAfter:    "s2 := strings.Clone(s1)",
			Rules: []ir.Rule{{
				Line:            70,
				SyntaxPatterns:  []ir.PatternString{{Line: 70, Value: "string([]byte($s))"}},
				ReportTemplate:  "$$ => strings.Clone($s)",
				SuggestTemplate: "strings.Clone($s)",
				WhereExpr: ir.FilterExpr{
					Line: 71,
					Op:   ir.FilterAndOp,
					Src:  "m[\"s\"].Type.Is(`string`) &&\n\t!m[\"s\"].Const &&\n\tm.GoVersion().GreaterEqThan(\"1.18\")",
					Args: []ir.FilterExpr{
						{
							Line: 71,
							Op:   ir.FilterAndOp,
							Src:  "m[\"s\"].Type.Is(`string`) &&\n\t!m[\"s\"].Const",
							Args: []ir.FilterExpr{
								{
									Line:  71,
									Op:    ir.FilterVarTypeIsOp,
									Src:   "m[\"s\"].Type.Is(`string`)",
									Value: "s",
									Args:  []ir.FilterExpr{{Line: 71, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
								},
								{
									Line: 72,
									Op:   ir.FilterNotOp,
									Src:  "!m[\"s\"].Const",
									Args: []ir.FilterExpr{{
										Line:  72,
										Op:    ir.FilterVarConstOp,
										Src:   "m[\"s\"].Const",
										Value: "s",
									}},
								},
							},
						},
						{
							Line:  73,
							Op:    ir.FilterGoVersionGreaterEqThanOp,
							Src:   "m.GoVersion().GreaterEqThan(\"1.18\")",
							Value: "1.18",
						},
					},
				},
			}},
		},
		{
			Line:        81,
			Name:        "equalFold",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects unoptimal strings/bytes case-insensitive comparison",
			DocBefore:   "strings.ToLower(x) == strings.ToLower(y)",
			DocAfter:    "strings.EqualFold(x, y)",
			Rules: []ir.Rule{
				{
					Line: 83,
					SyntaxPatterns: []ir.PatternString{
						{Line: 84, Value: "strings.ToLower($x) == $y"},
						{Line: 85, Value: "strings.ToLower($x) == strings.ToLower($y)"},
						{Line: 86, Value: "$x == strings.ToLower($y)"},
						{Line: 87, Value: "strings.ToUpper($x) == $y"},
						{Line: 88, Value: "strings.ToUpper($x) == strings.ToUpper($y)"},
						{Line: 89, Value: "$x == strings.ToUpper($y)"},
					},
					ReportTemplate:  "$$ => strings.EqualFold($x, $y)",
					SuggestTemplate: "strings.EqualFold($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 90,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 90,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 90, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 90, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 90,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 90, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 90, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				{
					Line: 94,
					SyntaxPatterns: []ir.PatternString{
						{Line: 95, Value: "strings.ToLower($x) != $y"},
						{Line: 96, Value: "strings.ToLower($x) != strings.ToLower($y)"},
						{Line: 97, Value: "$x != strings.ToLower($y)"},
						{Line: 98, Value: "strings.ToUpper($x) != $y"},
						{Line: 99, Value: "strings.ToUpper($x) != strings.ToUpper($y)"},
						{Line: 100, Value: "$x != strings.ToUpper($y)"},
					},
					ReportTemplate:  "$$ => !strings.EqualFold($x, $y)",
					SuggestTemplate: "!strings.EqualFold($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 101,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 101,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 101, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 101, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 101,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 101, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 101, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				{
					Line: 105,
					SyntaxPatterns: []ir.PatternString{
						{Line: 106, Value: "bytes.Equal(bytes.ToLower($x), $y)"},
						{Line: 107, Value: "bytes.Equal(bytes.ToLower($x), bytes.ToLower($y))"},
						{Line: 108, Value: "bytes.Equal($x, bytes.ToLower($y))"},
						{Line: 109, Value: "bytes.Equal(bytes.ToUpper($x), $y)"},
						{Line: 110, Value: "bytes.Equal(bytes.ToUpper($x), bytes.ToUpper($y))"},
						{Line: 111, Value: "bytes.Equal($x, bytes.ToUpper($y))"},
					},
					ReportTemplate:  "$$ => bytes.EqualFold($x, $y)",
					SuggestTemplate: "bytes.EqualFold($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 112,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 112,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 112, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 112, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 112,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 112, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 112, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				{
					Line: 116,
					SyntaxPatterns: []ir.PatternString{
						{Line: 117, Value: "strings.HasPrefix(strings.ToLower($x), $y)"},
						{Line: 118, Value: "strings.HasPrefix(strings.ToUpper($x), $y)"},
					},
					ReportTemplate:  "$$ => (len($x) >= len($y) && strings.EqualFold($x[:len($y)], $y))",
					SuggestTemplate: "(len($x) >= len($y) && strings.EqualFold($x[:len($y)], $y))",
					WhereExpr: ir.FilterExpr{
						Line: 119,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 119,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 119, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 119, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 119,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 119, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 119, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				{
					Line: 121,
					SyntaxPatterns: []ir.PatternString{
						{Line: 122, Value: "strings.HasSuffix(strings.ToLower($x), $y)"},
						{Line: 123, Value: "strings.HasSuffix(strings.ToUpper($x), $y)"},
					},
					ReportTemplate:  "$$ => (len($x) >= len($y) && strings.EqualFold($x[len($x)-len($y):], $y))",
					SuggestTemplate: "(len($x) >= len($y) && strings.EqualFold($x[len($x)-len($y):], $y))",
					WhereExpr: ir.FilterExpr{
						Line: 124,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 124,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 124, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 124, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 124,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 124, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 124, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				{
					Line: 128,
					SyntaxPatterns: []ir.PatternString{
						{Line: 129, Value: "bytes.HasPrefix(bytes.ToLower($x), $y)"},
						{Line: 130, Value: "bytes.HasPrefix(bytes.ToUpper($x), $y)"},
					},
					ReportTemplate:  "$$ => (len($x) >= len($y) && bytes.EqualFold($x[:len($y)], $y))",
					SuggestTemplate: "(len($x) >= len($y) && bytes.EqualFold($x[:len($y)], $y))",
					WhereExpr: ir.FilterExpr{
						Line: 131,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 131,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 131, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 131, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 131,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 131, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 131, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				{
					Line: 133,
					SyntaxPatterns: []ir.PatternString{
						{Line: 134, Value: "bytes.HasSuffix(bytes.ToLower($x), $y)"},
						{Line: 135, Value: "bytes.HasSuffix(bytes.ToUpper($x), $y)"},
					},
					ReportTemplate:  "$$ => (len($x) >= len($y) && bytes.EqualFold($x[len($x)-len($y):], $y))",
					SuggestTemplate: "(len($x) >= len($y) && bytes.EqualFold($x[len($x)-len($y):], $y))",
					WhereExpr: ir.FilterExpr{
						Line: 136,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							{
								Line: 136,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									{Line: 136, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									{Line: 136, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							{
								Line: 136,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									{Line: 136, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									{Line: 136, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
			},
		},
		{
			Line:        142,
			Name:        "redundantSprint",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects redundant fmt.Sprint calls",
			Rules: []ir.Rule{
				{
					Line: 143,
					SyntaxPatterns: []ir.PatternString{
						{Line: 143, Value: "fmt.Sprint($x)"},
						{Line: 143, Value: "fmt.Sprintf(\"%s\", $x)"},
						{Line: 143, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $x.String()",
					SuggestTemplate: "$x.String()",
					WhereExpr: ir.FilterExpr{
						Line:  144,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"x\"].Type.Implements(`fmt.Stringer`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 144, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"}},
					},
				},
				{
					Line: 147,
					SyntaxPatterns: []ir.PatternString{
						{Line: 147, Value: "fmt.Sprint($x)"},
						{Line: 147, Value: "fmt.Sprintf(\"%s\", $x)"},
						{Line: 147, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $x.Error()",
					SuggestTemplate: "$x.Error()",
					WhereExpr: ir.FilterExpr{
						Line:  148,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"x\"].Type.Implements(`error`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 148, Op: ir.FilterStringOp, Src: "`error`", Value: "error"}},
					},
				},
				{
					Line: 151,
					SyntaxPatterns: []ir.PatternString{
						{Line: 151, Value: "fmt.Sprint($x)"},
						{Line: 151, Value: "fmt.Sprintf(\"%s\", $x)"},
						{Line: 151, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $x",
					SuggestTemplate: "$x",
					WhereExpr: ir.FilterExpr{
						Line:  152,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`string`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 152, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line: 155,
					SyntaxPatterns: []ir.PatternString{
						{Line: 155, Value: "fmt.Sprint($x)"},
						{Line: 155, Value: "fmt.Sprintf(\"%s\", $x)"},
						{Line: 155, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => string($x)",
					SuggestTemplate: "string($x)",
					WhereExpr: ir.FilterExpr{
						Line: 156,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.ConvertibleTo(`string`) && !m[\"x\"].Type.OfKind(\"numeric\")",
						Args: []ir.FilterExpr{
							{
								Line:  156,
								Op:    ir.FilterVarTypeConvertibleToOp,
								Src:   "m[\"x\"].Type.ConvertibleTo(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 156, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line: 156,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"x\"].Type.OfKind(\"numeric\")",
								Args: []ir.FilterExpr{{
									Line:  156,
									Op:    ir.FilterVarTypeOfKindOp,
									Src:   "m[\"x\"].Type.OfKind(\"numeric\")",
									Value: "x",
									Args:  []ir.FilterExpr{{Line: 156, Op: ir.FilterStringOp, Src: "\"numeric\"", Value: "numeric"}},
								}},
							},
						},
					},
				},
			},
		},
		{
			Line:        164,
			Name:        "redundantFprint",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects redundant fmt.Fprint calls",
			DocBefore:   "fmt.Fprintf(w, \"%s\", data)",
			DocAfter:    "w.WriteString(data.String())",
			Rules: []ir.Rule{
				{
					Line: 165,
					SyntaxPatterns: []ir.PatternString{
						{Line: 165, Value: "fmt.Fprint($w, $x)"},
						{Line: 165, Value: "fmt.Fprintf($w, \"%s\", $x)"},
						{Line: 165, Value: "fmt.Fprintf($w, \"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $w.WriteString($x.String())",
					SuggestTemplate: "$w.WriteString($x.String())",
					WhereExpr: ir.FilterExpr{
						Line: 166,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Implements(`fmt.Stringer`) && m[\"w\"].Type.Implements(`io.StringWriter`)",
						Args: []ir.FilterExpr{
							{
								Line:  166,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"x\"].Type.Implements(`fmt.Stringer`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 166, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"}},
							},
							{
								Line:  166,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"w\"].Type.Implements(`io.StringWriter`)",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 166, Op: ir.FilterStringOp, Src: "`io.StringWriter`", Value: "io.StringWriter"}},
							},
						},
					},
				},
				{
					Line: 169,
					SyntaxPatterns: []ir.PatternString{
						{Line: 169, Value: "fmt.Fprint($w, $x)"},
						{Line: 169, Value: "fmt.Fprintf($w, \"%s\", $x)"},
						{Line: 169, Value: "fmt.Fprintf($w, \"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $w.WriteString($x.Error())",
					SuggestTemplate: "$w.WriteString($x.Error())",
					WhereExpr: ir.FilterExpr{
						Line: 170,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Implements(`error`) && m[\"w\"].Type.Implements(`io.StringWriter`)",
						Args: []ir.FilterExpr{
							{
								Line:  170,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"x\"].Type.Implements(`error`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 170, Op: ir.FilterStringOp, Src: "`error`", Value: "error"}},
							},
							{
								Line:  170,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"w\"].Type.Implements(`io.StringWriter`)",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 170, Op: ir.FilterStringOp, Src: "`io.StringWriter`", Value: "io.StringWriter"}},
							},
						},
					},
				},
				{
					Line: 173,
					SyntaxPatterns: []ir.PatternString{
						{Line: 173, Value: "fmt.Fprint($w, $x)"},
						{Line: 173, Value: "fmt.Fprintf($w, \"%s\", $x)"},
						{Line: 173, Value: "fmt.Fprintf($w, \"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $w.WriteString($x)",
					SuggestTemplate: "$w.WriteString($x)",
					WhereExpr: ir.FilterExpr{
						Line: 174,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"w\"].Type.Implements(`io.StringWriter`)",
						Args: []ir.FilterExpr{
							{
								Line:  174,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 174, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  174,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"w\"].Type.Implements(`io.StringWriter`)",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 174, Op: ir.FilterStringOp, Src: "`io.StringWriter`", Value: "io.StringWriter"}},
							},
						},
					},
				},
				{
					Line: 177,
					SyntaxPatterns: []ir.PatternString{
						{Line: 177, Value: "fmt.Fprint($w, $x)"},
						{Line: 177, Value: "fmt.Fprintf($w, \"%s\", $x)"},
						{Line: 177, Value: "fmt.Fprintf($w, \"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $w.Write($x)",
					SuggestTemplate: "$w.Write($x)",
					WhereExpr: ir.FilterExpr{
						Line:  178,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`[]byte`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 178, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
					},
				},
			},
		},
		{
			Line:        186,
			Name:        "sliceClone",
			MatcherName: "m",
			DocTags:     []string{"o2", "score2"},
			DocSummary:  "Detects slice copying patterns that can be optimized",
			DocBefore:   "dst := append([]int(nil), src...)",
			DocAfter:    "dst := make([]int, len(src)); copy(dst, src)",
			Rules: []ir.Rule{
				{
					Line: 187,
					SyntaxPatterns: []ir.PatternString{
						{Line: 187, Value: "$dst = append([]$elem(nil), $src...)"},
						{Line: 187, Value: "$dst = append([]$elem{}, $src...)"},
					},
					ReportTemplate:  "$$ => $dst = make([]$elem, len($src)); copy($dst, $src)",
					SuggestTemplate: "$dst = make([]$elem, len($src)); copy($dst, $src)",
					WhereExpr: ir.FilterExpr{
						Line: 188,
						Op:   ir.FilterNotOp,
						Src:  "!m[\"elem\"].Type.HasPointers()",
						Args: []ir.FilterExpr{{
							Line:  188,
							Op:    ir.FilterVarTypeHasPointersOp,
							Src:   "m[\"elem\"].Type.HasPointers()",
							Value: "elem",
						}},
					},
				},
				{
					Line: 190,
					SyntaxPatterns: []ir.PatternString{
						{Line: 190, Value: "$dst := append([]$elem(nil), $src...)"},
						{Line: 190, Value: "$dst := append([]$elem{}, $src...)"},
					},
					ReportTemplate:  "$$ => $dst := make([]$elem, len($src)); copy($dst, $src)",
					SuggestTemplate: "$dst := make([]$elem, len($src)); copy($dst, $src)",
					WhereExpr: ir.FilterExpr{
						Line: 191,
						Op:   ir.FilterNotOp,
						Src:  "!m[\"elem\"].Type.HasPointers()",
						Args: []ir.FilterExpr{{
							Line:  191,
							Op:    ir.FilterVarTypeHasPointersOp,
							Src:   "m[\"elem\"].Type.HasPointers()",
							Value: "elem",
						}},
					},
				},
			},
		},
		{
			Line:        197,
			Name:        "stringsJoinConcat",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detect strings.Join usages that can be rewritten as a string concat",
			Rules: []ir.Rule{
				{
					Line:            198,
					SyntaxPatterns:  []ir.PatternString{{Line: 198, Value: "strings.Join([]string{$x, $y}, \"\")"}},
					ReportTemplate:  "$$ => $x + $y",
					SuggestTemplate: "$x + $y",
					WhereExpr: ir.FilterExpr{
						Line: 199,
						Op:   ir.FilterAndOp,
						Src:  "!m[\"x\"].Const && !m[\"y\"].Const",
						Args: []ir.FilterExpr{
							{
								Line: 199,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"x\"].Const",
								Args: []ir.FilterExpr{{
									Line:  199,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"x\"].Const",
									Value: "x",
								}},
							},
							{
								Line: 199,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"y\"].Const",
								Args: []ir.FilterExpr{{
									Line:  199,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"y\"].Const",
									Value: "y",
								}},
							},
						},
					},
				},
				{
					Line:            201,
					SyntaxPatterns:  []ir.PatternString{{Line: 201, Value: "strings.Join([]string{$x, $y, $z}, \"\")"}},
					ReportTemplate:  "$$ => $x + $y + $z",
					SuggestTemplate: "$x + $y + $z",
					WhereExpr: ir.FilterExpr{
						Line: 202,
						Op:   ir.FilterAndOp,
						Src:  "!m[\"x\"].Const && !m[\"y\"].Const && !m[\"z\"].Const",
						Args: []ir.FilterExpr{
							{
								Line: 202,
								Op:   ir.FilterAndOp,
								Src:  "!m[\"x\"].Const && !m[\"y\"].Const",
								Args: []ir.FilterExpr{
									{
										Line: 202,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"x\"].Const",
										Args: []ir.FilterExpr{{
											Line:  202,
											Op:    ir.FilterVarConstOp,
											Src:   "m[\"x\"].Const",
											Value: "x",
										}},
									},
									{
										Line: 202,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Const",
										Args: []ir.FilterExpr{{
											Line:  202,
											Op:    ir.FilterVarConstOp,
											Src:   "m[\"y\"].Const",
											Value: "y",
										}},
									},
								},
							},
							{
								Line: 202,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"z\"].Const",
								Args: []ir.FilterExpr{{
									Line:  202,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"z\"].Const",
									Value: "z",
								}},
							},
						},
					},
				},
				{
					Line:            205,
					SyntaxPatterns:  []ir.PatternString{{Line: 205, Value: "strings.Join([]string{$x, $y}, $glue)"}},
					ReportTemplate:  "$$ => $x + $glue + $y",
					SuggestTemplate: "$x + $glue + $y",
					WhereExpr: ir.FilterExpr{
						Line: 206,
						Op:   ir.FilterAndOp,
						Src:  "!m[\"x\"].Const && !m[\"y\"].Const",
						Args: []ir.FilterExpr{
							{
								Line: 206,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"x\"].Const",
								Args: []ir.FilterExpr{{
									Line:  206,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"x\"].Const",
									Value: "x",
								}},
							},
							{
								Line: 206,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"y\"].Const",
								Args: []ir.FilterExpr{{
									Line:  206,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"y\"].Const",
									Value: "y",
								}},
							},
						},
					},
				},
				{
					Line:            209,
					SyntaxPatterns:  []ir.PatternString{{Line: 209, Value: "strings.Join([]string{$x, $y, $z}, $glue)"}},
					ReportTemplate:  "$$ => $x + $glue + $y + $glue + $z",
					SuggestTemplate: "$x + $glue + $y + $glue + $z",
					WhereExpr: ir.FilterExpr{
						Line: 210,
						Op:   ir.FilterAndOp,
						Src:  "m[\"glue\"].Const && !m[\"x\"].Const && !m[\"y\"].Const && !m[\"z\"].Const",
						Args: []ir.FilterExpr{
							{
								Line: 210,
								Op:   ir.FilterAndOp,
								Src:  "m[\"glue\"].Const && !m[\"x\"].Const && !m[\"y\"].Const",
								Args: []ir.FilterExpr{
									{
										Line: 210,
										Op:   ir.FilterAndOp,
										Src:  "m[\"glue\"].Const && !m[\"x\"].Const",
										Args: []ir.FilterExpr{
											{
												Line:  210,
												Op:    ir.FilterVarConstOp,
												Src:   "m[\"glue\"].Const",
												Value: "glue",
											},
											{
												Line: 210,
												Op:   ir.FilterNotOp,
												Src:  "!m[\"x\"].Const",
												Args: []ir.FilterExpr{{
													Line:  210,
													Op:    ir.FilterVarConstOp,
													Src:   "m[\"x\"].Const",
													Value: "x",
												}},
											},
										},
									},
									{
										Line: 210,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Const",
										Args: []ir.FilterExpr{{
											Line:  210,
											Op:    ir.FilterVarConstOp,
											Src:   "m[\"y\"].Const",
											Value: "y",
										}},
									},
								},
							},
							{
								Line: 210,
								Op:   ir.FilterNotOp,
								Src:  "!m[\"z\"].Const",
								Args: []ir.FilterExpr{{
									Line:  210,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"z\"].Const",
									Value: "z",
								}},
							},
						},
					},
				},
			},
		},
		{
			Line:        218,
			Name:        "sprintConcat",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects sprint calls that can be rewritten as a string concat",
			DocBefore:   "fmt.Sprintf(\"%s%s\", x, y)",
			DocAfter:    "x + y",
			Rules: []ir.Rule{
				{
					Line:            219,
					SyntaxPatterns:  []ir.PatternString{{Line: 219, Value: "fmt.Sprintf(\"%s%s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x + $y",
					SuggestTemplate: "$x + $y",
					WhereExpr: ir.FilterExpr{
						Line: 220,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  220,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 220, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  220,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 220, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            223,
					SyntaxPatterns:  []ir.PatternString{{Line: 223, Value: "fmt.Sprintf(\"%s%s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x.String() + $y.String()",
					SuggestTemplate: "$x.String() + $y.String()",
					WhereExpr: ir.FilterExpr{
						Line: 224,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Implements(`fmt.Stringer`) && m[\"y\"].Type.Implements(`fmt.Stringer`)",
						Args: []ir.FilterExpr{
							{
								Line:  224,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"x\"].Type.Implements(`fmt.Stringer`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 224, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"}},
							},
							{
								Line:  224,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"y\"].Type.Implements(`fmt.Stringer`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 224, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        232,
			Name:        "sprintfError",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects sprintf calls that are used to create an error",
			DocBefore:   "errors.New(fmt.Sprintf(\"%s:%d\", file, line))",
			DocAfter:    "fmt.Errorf(\"%s:%d\", file, line)",
			Rules: []ir.Rule{{
				Line:            233,
				SyntaxPatterns:  []ir.PatternString{{Line: 233, Value: "errors.New(fmt.Sprintf($format, $*args))"}},
				ReportTemplate:  "$$ => fmt.Errorf($format, $args)",
				SuggestTemplate: "fmt.Errorf($format, $args)",
			}},
		},
		{
			Line:        241,
			Name:        "strconv",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects fmt uses that can be replaced with strconv",
			DocBefore:   "fmt.Sprintf(\"%d\", i)",
			DocAfter:    "strconv.Itoa(i)",
			Rules: []ir.Rule{
				{
					Line: 245,
					SyntaxPatterns: []ir.PatternString{
						{Line: 245, Value: "fmt.Sprintf(\"%d\", $x)"},
						{Line: 245, Value: "fmt.Sprintf(\"%v\", $x)"},
						{Line: 245, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.Itoa($x)",
					SuggestTemplate: "strconv.Itoa($x)",
					WhereExpr: ir.FilterExpr{
						Line:  246,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`int`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 246, Op: ir.FilterStringOp, Src: "`int`", Value: "int"}},
					},
				},
				{
					Line: 250,
					SyntaxPatterns: []ir.PatternString{
						{Line: 250, Value: "fmt.Sprintf(\"%d\", $x)"},
						{Line: 250, Value: "fmt.Sprintf(\"%v\", $x)"},
						{Line: 250, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatInt($x, 10)",
					SuggestTemplate: "strconv.FormatInt($x, 10)",
					WhereExpr: ir.FilterExpr{
						Line:  251,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`int64`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 251, Op: ir.FilterStringOp, Src: "`int64`", Value: "int64"}},
					},
				},
				{
					Line:            252,
					SyntaxPatterns:  []ir.PatternString{{Line: 252, Value: "fmt.Sprintf(\"%x\", $x)"}},
					ReportTemplate:  "$$ => strconv.FormatInt($x, 16)",
					SuggestTemplate: "strconv.FormatInt($x, 16)",
					WhereExpr: ir.FilterExpr{
						Line:  253,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`int64`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 253, Op: ir.FilterStringOp, Src: "`int64`", Value: "int64"}},
					},
				},
				{
					Line: 254,
					SyntaxPatterns: []ir.PatternString{
						{Line: 254, Value: "fmt.Sprintf(\"%d\", $x)"},
						{Line: 254, Value: "fmt.Sprintf(\"%v\", $x)"},
						{Line: 254, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatUint($x, 10)",
					SuggestTemplate: "strconv.FormatUint($x, 10)",
					WhereExpr: ir.FilterExpr{
						Line:  255,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`uint64`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 255, Op: ir.FilterStringOp, Src: "`uint64`", Value: "uint64"}},
					},
				},
				{
					Line:            256,
					SyntaxPatterns:  []ir.PatternString{{Line: 256, Value: "fmt.Sprintf(\"%x\", $x)"}},
					ReportTemplate:  "$$ => strconv.FormatUint($x, 16)",
					SuggestTemplate: "strconv.FormatUint($x, 16)",
					WhereExpr: ir.FilterExpr{
						Line:  257,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`uint64`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 257, Op: ir.FilterStringOp, Src: "`uint64`", Value: "uint64"}},
					},
				},
				{
					Line: 259,
					SyntaxPatterns: []ir.PatternString{
						{Line: 259, Value: "fmt.Sprintf(\"%d\", $x)"},
						{Line: 259, Value: "fmt.Sprintf(\"%v\", $x)"},
						{Line: 259, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatInt(int64($x), 10)",
					SuggestTemplate: "strconv.FormatInt(int64($x), 10)",
					WhereExpr: ir.FilterExpr{
						Line:  260,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`int`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 260, Op: ir.FilterStringOp, Src: "`int`", Value: "int"}},
					},
				},
				{
					Line:            261,
					SyntaxPatterns:  []ir.PatternString{{Line: 261, Value: "fmt.Sprintf(\"%x\", $x)"}},
					ReportTemplate:  "$$ => strconv.FormatInt(int64($x), 16)",
					SuggestTemplate: "strconv.FormatInt(int64($x), 16)",
					WhereExpr: ir.FilterExpr{
						Line:  262,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`int`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 262, Op: ir.FilterStringOp, Src: "`int`", Value: "int"}},
					},
				},
				{
					Line: 264,
					SyntaxPatterns: []ir.PatternString{
						{Line: 264, Value: "fmt.Sprintf(\"%d\", $x)"},
						{Line: 264, Value: "fmt.Sprintf(\"%v\", $x)"},
						{Line: 264, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatUint(uint64($x), 10)",
					SuggestTemplate: "strconv.FormatUint(uint64($x), 10)",
					WhereExpr: ir.FilterExpr{
						Line:  265,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`uint`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 265, Op: ir.FilterStringOp, Src: "`uint`", Value: "uint"}},
					},
				},
				{
					Line:            266,
					SyntaxPatterns:  []ir.PatternString{{Line: 266, Value: "fmt.Sprintf(\"%x\", $x)"}},
					ReportTemplate:  "$$ => strconv.FormatUint(uint64($x), 16)",
					SuggestTemplate: "strconv.FormatUint(uint64($x), 16)",
					WhereExpr: ir.FilterExpr{
						Line:  267,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`uint`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 267, Op: ir.FilterStringOp, Src: "`uint`", Value: "uint"}},
					},
				},
			},
		},
		{
			Line:        274,
			Name:        "appendAPI",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects cases that can benefit from append-friendly APIs",
			DocBefore:   "b = append(b, strconv.Itoa(v)...)",
			DocAfter:    "b = strconv.AppendInt(b, v, 10)",
			Rules: []ir.Rule{
				{
					Line:            282,
					SyntaxPatterns:  []ir.PatternString{{Line: 282, Value: "$b = append($b, strconv.Itoa($x)...)"}},
					ReportTemplate:  "$$ => $b = strconv.AppendInt($b, int64($x), 10)",
					SuggestTemplate: "$b = strconv.AppendInt($b, int64($x), 10)",
				},
				{
					Line:            284,
					SyntaxPatterns:  []ir.PatternString{{Line: 284, Value: "$b = append($b, strconv.FormatInt($x, $base)...)"}},
					ReportTemplate:  "$$ => $b = strconv.AppendInt($b, $x, $base)",
					SuggestTemplate: "$b = strconv.AppendInt($b, $x, $base)",
				},
				{
					Line:            286,
					SyntaxPatterns:  []ir.PatternString{{Line: 286, Value: "$b = append($b, strconv.FormatUint($x, $base)...)"}},
					ReportTemplate:  "$$ => $b = strconv.AppendUint($b, $x, $base)",
					SuggestTemplate: "$b = strconv.AppendUint($b, $x, $base)",
				},
				{
					Line:            289,
					SyntaxPatterns:  []ir.PatternString{{Line: 289, Value: "$b = append($b, $t.Format($layout)...)"}},
					ReportTemplate:  "$$ => $b = $t.AppendFormat($b, $layout)",
					SuggestTemplate: "$b = $t.AppendFormat($b, $layout)",
					WhereExpr: ir.FilterExpr{
						Line: 290,
						Op:   ir.FilterOrOp,
						Src:  "m[\"t\"].Type.Is(`time.Time`) || m[\"t\"].Type.Is(`*time.Time`)",
						Args: []ir.FilterExpr{
							{
								Line:  290,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"t\"].Type.Is(`time.Time`)",
								Value: "t",
								Args:  []ir.FilterExpr{{Line: 290, Op: ir.FilterStringOp, Src: "`time.Time`", Value: "time.Time"}},
							},
							{
								Line:  290,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"t\"].Type.Is(`*time.Time`)",
								Value: "t",
								Args:  []ir.FilterExpr{{Line: 290, Op: ir.FilterStringOp, Src: "`*time.Time`", Value: "*time.Time"}},
							},
						},
					},
				},
				{
					Line:            293,
					SyntaxPatterns:  []ir.PatternString{{Line: 293, Value: "$b = append($b, $v.String()...)"}},
					ReportTemplate:  "$$ => $b = $v.Append($b, 'g', 10)",
					SuggestTemplate: "$b = $v.Append($b, 'g', 10)",
					WhereExpr: ir.FilterExpr{
						Line: 294,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Float`) || m[\"v\"].Type.Is(`*big.Float`)",
						Args: []ir.FilterExpr{
							{
								Line:  294,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Float`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 294, Op: ir.FilterStringOp, Src: "`big.Float`", Value: "big.Float"}},
							},
							{
								Line:  294,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Float`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 294, Op: ir.FilterStringOp, Src: "`*big.Float`", Value: "*big.Float"}},
							},
						},
					},
				},
				{
					Line:            296,
					SyntaxPatterns:  []ir.PatternString{{Line: 296, Value: "$b = append($b, $v.Text($format, $prec)...)"}},
					ReportTemplate:  "$$ => $b = $v.Append($b, $format, $prec)",
					SuggestTemplate: "$b = $v.Append($b, $format, $prec)",
					WhereExpr: ir.FilterExpr{
						Line: 297,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Float`) || m[\"v\"].Type.Is(`*big.Float`)",
						Args: []ir.FilterExpr{
							{
								Line:  297,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Float`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 297, Op: ir.FilterStringOp, Src: "`big.Float`", Value: "big.Float"}},
							},
							{
								Line:  297,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Float`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 297, Op: ir.FilterStringOp, Src: "`*big.Float`", Value: "*big.Float"}},
							},
						},
					},
				},
				{
					Line:            300,
					SyntaxPatterns:  []ir.PatternString{{Line: 300, Value: "$b = append($b, $v.String()...)"}},
					ReportTemplate:  "$$ => $b = $v.Append($b, 10)",
					SuggestTemplate: "$b = $v.Append($b, 10)",
					WhereExpr: ir.FilterExpr{
						Line: 301,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Int`) || m[\"v\"].Type.Is(`*big.Int`)",
						Args: []ir.FilterExpr{
							{
								Line:  301,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Int`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 301, Op: ir.FilterStringOp, Src: "`big.Int`", Value: "big.Int"}},
							},
							{
								Line:  301,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Int`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 301, Op: ir.FilterStringOp, Src: "`*big.Int`", Value: "*big.Int"}},
							},
						},
					},
				},
				{
					Line:            303,
					SyntaxPatterns:  []ir.PatternString{{Line: 303, Value: "$b = append($b, $v.Text($base)...)"}},
					ReportTemplate:  "$$ => $b = $v.Append($b, $base)",
					SuggestTemplate: "$b = $v.Append($b, $base)",
					WhereExpr: ir.FilterExpr{
						Line: 304,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Int`) || m[\"v\"].Type.Is(`*big.Int`)",
						Args: []ir.FilterExpr{
							{
								Line:  304,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Int`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 304, Op: ir.FilterStringOp, Src: "`big.Int`", Value: "big.Int"}},
							},
							{
								Line:  304,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Int`)",
								Value: "v",
								Args:  []ir.FilterExpr{{Line: 304, Op: ir.FilterStringOp, Src: "`*big.Int`", Value: "*big.Int"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        312,
			Name:        "convReorder",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects patterns that can be reordered to make the code faster",
			DocBefore:   "strings.TrimSpace(string(b))",
			DocAfter:    "string(bytes.TrimSpace(b))",
			Rules: []ir.Rule{
				{
					Line:            318,
					SyntaxPatterns:  []ir.PatternString{{Line: 318, Value: "strings.TrimSpace(string($b))"}},
					ReportTemplate:  "$$ => string(bytes.TrimSpace($b))",
					SuggestTemplate: "string(bytes.TrimSpace($b))",
					WhereExpr: ir.FilterExpr{
						Line:  319,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"b\"].Type.Is(`[]byte`)",
						Value: "b",
						Args:  []ir.FilterExpr{{Line: 319, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
					},
				},
				{
					Line:            322,
					SyntaxPatterns:  []ir.PatternString{{Line: 322, Value: "bytes.TrimSpace([]byte($s))"}},
					ReportTemplate:  "$$ => []byte(strings.TrimSpace($s))",
					SuggestTemplate: "[]byte(strings.TrimSpace($s))",
					WhereExpr: ir.FilterExpr{
						Line:  323,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"s\"].Type.Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 323, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line:            326,
					SyntaxPatterns:  []ir.PatternString{{Line: 326, Value: "strings.TrimPrefix(string($b1), string($b2))"}},
					ReportTemplate:  "$$ => string(bytes.TrimPrefix($b1, $b2))",
					SuggestTemplate: "string(bytes.TrimPrefix($b1, $b2))",
					WhereExpr: ir.FilterExpr{
						Line: 327,
						Op:   ir.FilterAndOp,
						Src:  "m[\"b1\"].Type.Is(`[]byte`) && m[\"b2\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line:  327,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b1\"].Type.Is(`[]byte`)",
								Value: "b1",
								Args:  []ir.FilterExpr{{Line: 327, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
							{
								Line:  327,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b2\"].Type.Is(`[]byte`)",
								Value: "b2",
								Args:  []ir.FilterExpr{{Line: 327, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            330,
					SyntaxPatterns:  []ir.PatternString{{Line: 330, Value: "bytes.TrimPrefix([]byte($s1), []byte($s2))"}},
					ReportTemplate:  "$$ => []byte(strings.TrimPrefix($s1, $s2))",
					SuggestTemplate: "[]byte(strings.TrimPrefix($s1, $s2))",
					WhereExpr: ir.FilterExpr{
						Line: 331,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s1\"].Type.Is(`string`) && m[\"s2\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  331,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s1\"].Type.Is(`string`)",
								Value: "s1",
								Args:  []ir.FilterExpr{{Line: 331, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  331,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s2\"].Type.Is(`string`)",
								Value: "s2",
								Args:  []ir.FilterExpr{{Line: 331, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        339,
			Name:        "slicedConv",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects sliced slice copying that can be optimized",
			DocBefore:   "string(b)[:n]",
			DocAfter:    "string(b[:n])",
			Rules: []ir.Rule{
				{
					Line:            340,
					SyntaxPatterns:  []ir.PatternString{{Line: 340, Value: "string($b)[:$n]"}},
					ReportTemplate:  "$$ => string($b[:$n])",
					SuggestTemplate: "string($b[:$n])",
					WhereExpr: ir.FilterExpr{
						Line:  341,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"b\"].Type.Is(`[]byte`)",
						Value: "b",
						Args:  []ir.FilterExpr{{Line: 341, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
					},
				},
				{
					Line:            344,
					SyntaxPatterns:  []ir.PatternString{{Line: 344, Value: "[]byte($s)[:$n]"}},
					ReportTemplate:  "$$ => []byte($s[:$n])",
					SuggestTemplate: "[]byte($s[:$n])",
					WhereExpr: ir.FilterExpr{
						Line:  345,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"s\"].Type.Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 345, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
			},
		},
		{
			Line:        353,
			Name:        "stringCopyElim",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects redundant conversions between string and []byte",
			DocBefore:   "copy(b, []byte(s))",
			DocAfter:    "copy(b, s)",
			Rules: []ir.Rule{
				{
					Line:            354,
					SyntaxPatterns:  []ir.PatternString{{Line: 354, Value: "copy($b, []byte($s))"}},
					ReportTemplate:  "$$ => copy($b, $s)",
					SuggestTemplate: "copy($b, $s)",
					WhereExpr: ir.FilterExpr{
						Line:  355,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"s\"].Type.Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 355, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line:            358,
					SyntaxPatterns:  []ir.PatternString{{Line: 358, Value: "append($b, []byte($s)...)"}},
					ReportTemplate:  "$$ => append($b, $s...)",
					SuggestTemplate: "append($b, $s...)",
					WhereExpr: ir.FilterExpr{
						Line:  359,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"s\"].Type.Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 359, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line:            362,
					SyntaxPatterns:  []ir.PatternString{{Line: 362, Value: "len(string($b))"}},
					ReportTemplate:  "$$ => len($b)",
					SuggestTemplate: "len($b)",
					WhereExpr: ir.FilterExpr{
						Line:  362,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"b\"].Type.Is(`[]byte`)",
						Value: "b",
						Args:  []ir.FilterExpr{{Line: 362, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
					},
				},
				{
					Line:            364,
					SyntaxPatterns:  []ir.PatternString{{Line: 364, Value: "[]byte(strings.$f(string($b)))"}},
					ReportTemplate:  "$$ => bytes.$f($b)",
					SuggestTemplate: "bytes.$f($b)",
					WhereExpr: ir.FilterExpr{
						Line: 365,
						Op:   ir.FilterAndOp,
						Src:  "m[\"b\"].Type.Is(`[]byte`) &&\n\tm[\"f\"].Text.Matches(`ToUpper|ToLower|TrimSpace`)",
						Args: []ir.FilterExpr{
							{
								Line:  365,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 365, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
							{
								Line:  366,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"f\"].Text.Matches(`ToUpper|ToLower|TrimSpace`)",
								Value: "f",
								Args:  []ir.FilterExpr{{Line: 366, Op: ir.FilterStringOp, Src: "`ToUpper|ToLower|TrimSpace`", Value: "ToUpper|ToLower|TrimSpace"}},
							},
						},
					},
				},
				{
					Line:            369,
					SyntaxPatterns:  []ir.PatternString{{Line: 369, Value: "[]byte(strings.$f(string($b), $s2))"}},
					ReportTemplate:  "$$ => bytes.$f($b, []byte($s2))",
					SuggestTemplate: "bytes.$f($b, []byte($s2))",
					WhereExpr: ir.FilterExpr{
						Line: 370,
						Op:   ir.FilterAndOp,
						Src:  "m[\"b\"].Type.Is(`[]byte`) &&\n\tm[\"f\"].Text.Matches(`TrimPrefix|TrimSuffix`)",
						Args: []ir.FilterExpr{
							{
								Line:  370,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 370, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
							{
								Line:  371,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"f\"].Text.Matches(`TrimPrefix|TrimSuffix`)",
								Value: "f",
								Args:  []ir.FilterExpr{{Line: 371, Op: ir.FilterStringOp, Src: "`TrimPrefix|TrimSuffix`", Value: "TrimPrefix|TrimSuffix"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        379,
			Name:        "regexpStringCopyElim",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects inefficient regexp usage in regard to string/[]byte conversions",
			DocBefore:   "regexp.ReplaceAll([]byte(s), []byte(\"foo\"))",
			DocAfter:    "regexp.ReplaceAllString(s, \"foo\")",
			Rules: []ir.Rule{
				{
					Line:            382,
					SyntaxPatterns:  []ir.PatternString{{Line: 382, Value: "$re.Match([]byte($s))"}},
					ReportTemplate:  "$$ => $re.MatchString($s)",
					SuggestTemplate: "$re.MatchString($s)",
					WhereExpr: ir.FilterExpr{
						Line: 383,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  383,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args:  []ir.FilterExpr{{Line: 383, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
							},
							{
								Line:  383,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 383, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            386,
					SyntaxPatterns:  []ir.PatternString{{Line: 386, Value: "$re.FindIndex([]byte($s))"}},
					ReportTemplate:  "$$ => $re.FindStringIndex($s)",
					SuggestTemplate: "$re.FindStringIndex($s)",
					WhereExpr: ir.FilterExpr{
						Line: 387,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  387,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args:  []ir.FilterExpr{{Line: 387, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
							},
							{
								Line:  387,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 387, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            390,
					SyntaxPatterns:  []ir.PatternString{{Line: 390, Value: "$re.FindAllIndex([]byte($s), $n)"}},
					ReportTemplate:  "$$ => $re.FindAllStringIndex($s, $n)",
					SuggestTemplate: "$re.FindAllStringIndex($s, $n)",
					WhereExpr: ir.FilterExpr{
						Line: 391,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  391,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args:  []ir.FilterExpr{{Line: 391, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
							},
							{
								Line:  391,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 391, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            394,
					SyntaxPatterns:  []ir.PatternString{{Line: 394, Value: "string($re.ReplaceAll([]byte($s), []byte($s2)))"}},
					ReportTemplate:  "$$ => $re.ReplaceAllString($s, $s2)",
					SuggestTemplate: "$re.ReplaceAllString($s, $s2)",
					WhereExpr: ir.FilterExpr{
						Line: 395,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`) && m[\"s2\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 395,
								Op:   ir.FilterAndOp,
								Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
								Args: []ir.FilterExpr{
									{
										Line:  395,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
										Value: "re",
										Args:  []ir.FilterExpr{{Line: 395, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
									},
									{
										Line:  395,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"s\"].Type.Is(`string`)",
										Value: "s",
										Args:  []ir.FilterExpr{{Line: 395, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
									},
								},
							},
							{
								Line:  395,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s2\"].Type.Is(`string`)",
								Value: "s2",
								Args:  []ir.FilterExpr{{Line: 395, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            398,
					SyntaxPatterns:  []ir.PatternString{{Line: 398, Value: "string($re.ReplaceAll([]byte($s), $b))"}},
					ReportTemplate:  "$$ => $re.ReplaceAllString($s, string($b))",
					SuggestTemplate: "$re.ReplaceAllString($s, string($b))",
					WhereExpr: ir.FilterExpr{
						Line: 399,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 399,
								Op:   ir.FilterAndOp,
								Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
								Args: []ir.FilterExpr{
									{
										Line:  399,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
										Value: "re",
										Args:  []ir.FilterExpr{{Line: 399, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
									},
									{
										Line:  399,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"s\"].Type.Is(`string`)",
										Value: "s",
										Args:  []ir.FilterExpr{{Line: 399, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
									},
								},
							},
							{
								Line:  399,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 399, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            404,
					SyntaxPatterns:  []ir.PatternString{{Line: 404, Value: "$re.MatchString(string($b))"}},
					ReportTemplate:  "$$ => $re.Match($b)",
					SuggestTemplate: "$re.Match($b)",
					WhereExpr: ir.FilterExpr{
						Line: 405,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line:  405,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args:  []ir.FilterExpr{{Line: 405, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
							},
							{
								Line:  405,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 405, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            408,
					SyntaxPatterns:  []ir.PatternString{{Line: 408, Value: "$re.FindStringIndex(string($b))"}},
					ReportTemplate:  "$$ => $re.FindIndex($b)",
					SuggestTemplate: "$re.FindIndex($b)",
					WhereExpr: ir.FilterExpr{
						Line: 409,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line:  409,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args:  []ir.FilterExpr{{Line: 409, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
							},
							{
								Line:  409,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 409, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            412,
					SyntaxPatterns:  []ir.PatternString{{Line: 412, Value: "$re.FindAllStringIndex(string($b), $n)"}},
					ReportTemplate:  "$$ => $re.FindAllIndex($b, $n)",
					SuggestTemplate: "$re.FindAllIndex($b, $n)",
					WhereExpr: ir.FilterExpr{
						Line: 413,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line:  413,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args:  []ir.FilterExpr{{Line: 413, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
							},
							{
								Line:  413,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 413, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            416,
					SyntaxPatterns:  []ir.PatternString{{Line: 416, Value: "[]byte($re.ReplaceAllString(string($b), string($b2)))"}},
					ReportTemplate:  "$$ => $re.ReplaceAll($b, $b2)",
					SuggestTemplate: "$re.ReplaceAll($b, $b2)",
					WhereExpr: ir.FilterExpr{
						Line: 417,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`) && m[\"b2\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 417,
								Op:   ir.FilterAndOp,
								Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`)",
								Args: []ir.FilterExpr{
									{
										Line:  417,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
										Value: "re",
										Args:  []ir.FilterExpr{{Line: 417, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
									},
									{
										Line:  417,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"b\"].Type.Is(`[]byte`)",
										Value: "b",
										Args:  []ir.FilterExpr{{Line: 417, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
									},
								},
							},
							{
								Line:  417,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b2\"].Type.Is(`[]byte`)",
								Value: "b2",
								Args:  []ir.FilterExpr{{Line: 417, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            420,
					SyntaxPatterns:  []ir.PatternString{{Line: 420, Value: "[]byte($re.ReplaceAllString(string($b), $s))"}},
					ReportTemplate:  "$$ => $re.ReplaceAll($b, []byte($s))",
					SuggestTemplate: "$re.ReplaceAll($b, []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 421,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 421,
								Op:   ir.FilterAndOp,
								Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"b\"].Type.Is(`[]byte`)",
								Args: []ir.FilterExpr{
									{
										Line:  421,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
										Value: "re",
										Args:  []ir.FilterExpr{{Line: 421, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"}},
									},
									{
										Line:  421,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"b\"].Type.Is(`[]byte`)",
										Value: "b",
										Args:  []ir.FilterExpr{{Line: 421, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
									},
								},
							},
							{
								Line:  421,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 421, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        430,
			Name:        "indexAlloc",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects strings.Index()-like calls that may allocate more than they should",
			DocBefore:   "strings.Index(string(x), y)",
			DocAfter:    "bytes.Index(x, []byte(y))",
			DocNote:     "See Go issue for details: https://github.com/golang/go/issues/25864",
			Rules: []ir.Rule{
				{
					Line:            434,
					SyntaxPatterns:  []ir.PatternString{{Line: 434, Value: "strings.$f(string($b1), string($b2))"}},
					ReportTemplate:  "$$ => bytes.$f($b1, $b2)",
					SuggestTemplate: "bytes.$f($b1, $b2)",
					WhereExpr: ir.FilterExpr{
						Line: 435,
						Op:   ir.FilterAndOp,
						Src:  "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`) &&\n\tm[\"b1\"].Type.Is(`[]byte`) && m[\"b2\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 435,
								Op:   ir.FilterAndOp,
								Src:  "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`) &&\n\tm[\"b1\"].Type.Is(`[]byte`)",
								Args: []ir.FilterExpr{
									{
										Line:  435,
										Op:    ir.FilterVarTextMatchesOp,
										Src:   "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`)",
										Value: "f",
										Args:  []ir.FilterExpr{{Line: 435, Op: ir.FilterStringOp, Src: "`Compare|Contains|HasPrefix|HasSuffix|EqualFold`", Value: "Compare|Contains|HasPrefix|HasSuffix|EqualFold"}},
									},
									{
										Line:  436,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"b1\"].Type.Is(`[]byte`)",
										Value: "b1",
										Args:  []ir.FilterExpr{{Line: 436, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
									},
								},
							},
							{
								Line:  436,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b2\"].Type.Is(`[]byte`)",
								Value: "b2",
								Args:  []ir.FilterExpr{{Line: 436, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            439,
					SyntaxPatterns:  []ir.PatternString{{Line: 439, Value: "bytes.$f([]byte($s1), []byte($s2))"}},
					ReportTemplate:  "$$ => strings.$f($s1, $s2)",
					SuggestTemplate: "strings.$f($s1, $s2)",
					WhereExpr: ir.FilterExpr{
						Line: 440,
						Op:   ir.FilterAndOp,
						Src:  "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`) &&\n\tm[\"s1\"].Type.Is(`string`) && m[\"s2\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 440,
								Op:   ir.FilterAndOp,
								Src:  "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`) &&\n\tm[\"s1\"].Type.Is(`string`)",
								Args: []ir.FilterExpr{
									{
										Line:  440,
										Op:    ir.FilterVarTextMatchesOp,
										Src:   "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`)",
										Value: "f",
										Args:  []ir.FilterExpr{{Line: 440, Op: ir.FilterStringOp, Src: "`Compare|Contains|HasPrefix|HasSuffix|EqualFold`", Value: "Compare|Contains|HasPrefix|HasSuffix|EqualFold"}},
									},
									{
										Line:  441,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"s1\"].Type.Is(`string`)",
										Value: "s1",
										Args:  []ir.FilterExpr{{Line: 441, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
									},
								},
							},
							{
								Line:  441,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s2\"].Type.Is(`string`)",
								Value: "s2",
								Args:  []ir.FilterExpr{{Line: 441, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            450,
					SyntaxPatterns:  []ir.PatternString{{Line: 450, Value: "strings.Index(string($x), $y)"}},
					ReportTemplate:  "$$ => bytes.Index($x, []byte($y))",
					SuggestTemplate: "bytes.Index($x, []byte($y))",
					WhereExpr: ir.FilterExpr{
						Line: 450,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeStrings(m)",
						Args: []ir.FilterExpr{
							{
								Line: 450,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 450,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 450, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 450, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 446,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  450,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 446, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  450,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`[]byte`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 447, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            451,
					SyntaxPatterns:  []ir.PatternString{{Line: 451, Value: "strings.Contains(string($x), $y)"}},
					ReportTemplate:  "$$ => bytes.Contains($x, []byte($y))",
					SuggestTemplate: "bytes.Contains($x, []byte($y))",
					WhereExpr: ir.FilterExpr{
						Line: 451,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeStrings(m)",
						Args: []ir.FilterExpr{
							{
								Line: 451,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 451,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 451, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 451, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 446,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  451,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 446, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  451,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`[]byte`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 447, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            452,
					SyntaxPatterns:  []ir.PatternString{{Line: 452, Value: "strings.HasPrefix(string($x), $y)"}},
					ReportTemplate:  "$$ => bytes.HasPrefix($x, []byte($y))",
					SuggestTemplate: "bytes.HasPrefix($x, []byte($y))",
					WhereExpr: ir.FilterExpr{
						Line: 452,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeStrings(m)",
						Args: []ir.FilterExpr{
							{
								Line: 452,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 452,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 452, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 452, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 446,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  452,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 446, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  452,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`[]byte`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 447, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            453,
					SyntaxPatterns:  []ir.PatternString{{Line: 453, Value: "strings.HasSuffix(string($x), $y)"}},
					ReportTemplate:  "$$ => bytes.HasSuffix($x, []byte($y))",
					SuggestTemplate: "bytes.HasSuffix($x, []byte($y))",
					WhereExpr: ir.FilterExpr{
						Line: 453,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeStrings(m)",
						Args: []ir.FilterExpr{
							{
								Line: 453,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 453,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 453, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 453, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 446,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  453,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 446, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  453,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`[]byte`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 447, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            461,
					SyntaxPatterns:  []ir.PatternString{{Line: 461, Value: "bytes.Index([]byte($x), $y)"}},
					ReportTemplate:  "$$ => strings.Index($x, string($y))",
					SuggestTemplate: "strings.Index($x, string($y))",
					WhereExpr: ir.FilterExpr{
						Line: 461,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeBytes(m)",
						Args: []ir.FilterExpr{
							{
								Line: 461,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 461,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 461, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 461, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 457,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  461,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 457, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  461,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 458, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            462,
					SyntaxPatterns:  []ir.PatternString{{Line: 462, Value: "bytes.Contains([]byte($x), $y)"}},
					ReportTemplate:  "$$ => strings.Contains($x, string($y))",
					SuggestTemplate: "strings.Contains($x, string($y))",
					WhereExpr: ir.FilterExpr{
						Line: 462,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeBytes(m)",
						Args: []ir.FilterExpr{
							{
								Line: 462,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 462,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 462, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 462, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 457,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  462,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 457, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  462,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 458, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            463,
					SyntaxPatterns:  []ir.PatternString{{Line: 463, Value: "bytes.HasPrefix([]byte($x), $y)"}},
					ReportTemplate:  "$$ => strings.HasPrefix($x, string($y))",
					SuggestTemplate: "strings.HasPrefix($x, string($y))",
					WhereExpr: ir.FilterExpr{
						Line: 463,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeBytes(m)",
						Args: []ir.FilterExpr{
							{
								Line: 463,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 463,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 463, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 463, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 457,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  463,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 457, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  463,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 458, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            464,
					SyntaxPatterns:  []ir.PatternString{{Line: 464, Value: "bytes.HasSuffix([]byte($x), $y)"}},
					ReportTemplate:  "$$ => strings.HasSuffix($x, string($y))",
					SuggestTemplate: "strings.HasSuffix($x, string($y))",
					WhereExpr: ir.FilterExpr{
						Line: 464,
						Op:   ir.FilterAndOp,
						Src:  "canOptimizeBytes(m)",
						Args: []ir.FilterExpr{
							{
								Line: 464,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure &&\n\t!m[\"y\"].Node.Is(`CallExpr`)",
								Args: []ir.FilterExpr{
									{
										Line: 464,
										Op:   ir.FilterAndOp,
										Src:  "m[\"x\"].Pure &&\n\n\tm[\"y\"].Pure",
										Args: []ir.FilterExpr{
											{Line: 464, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
											{Line: 464, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
										},
									},
									{
										Line: 457,
										Op:   ir.FilterNotOp,
										Src:  "!m[\"y\"].Node.Is(`CallExpr`)",
										Args: []ir.FilterExpr{{
											Line:  464,
											Op:    ir.FilterVarNodeIsOp,
											Src:   "m[\"y\"].Node.Is(`CallExpr`)",
											Value: "y",
											Args:  []ir.FilterExpr{{Line: 457, Op: ir.FilterStringOp, Src: "`CallExpr`", Value: "CallExpr"}},
										}},
									},
								},
							},
							{
								Line:  464,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 458, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        471,
			Name:        "writeByte",
			MatcherName: "m",
			DocTags:     []string{"o1", "score1"},
			DocSummary:  "Detects WriteRune calls with rune literal argument that is single byte and reports to use WriteByte instead",
			DocBefore:   "w.WriteRune('\\n')",
			DocAfter:    "w.WriteByte('\\n')",
			Rules: []ir.Rule{{
				Line:            475,
				SyntaxPatterns:  []ir.PatternString{{Line: 475, Value: "$w.WriteRune($c)"}},
				ReportTemplate:  "$$ => $w.WriteByte($c)",
				SuggestTemplate: "$w.WriteByte($c)",
				WhereExpr: ir.FilterExpr{
					Line: 476,
					Op:   ir.FilterAndOp,
					Src:  "m[\"w\"].Type.HasMethod(`io.ByteWriter.WriteByte`) && (m[\"c\"].Const && m[\"c\"].Value.Int() < runeSelf)",
					Args: []ir.FilterExpr{
						{
							Line:  476,
							Op:    ir.FilterVarTypeHasMethodOp,
							Src:   "m[\"w\"].Type.HasMethod(`io.ByteWriter.WriteByte`)",
							Value: "w",
							Args:  []ir.FilterExpr{{Line: 476, Op: ir.FilterStringOp, Src: "`io.ByteWriter.WriteByte`", Value: "io.ByteWriter.WriteByte"}},
						},
						{
							Line: 476,
							Op:   ir.FilterAndOp,
							Src:  "(m[\"c\"].Const && m[\"c\"].Value.Int() < runeSelf)",
							Args: []ir.FilterExpr{
								{
									Line:  476,
									Op:    ir.FilterVarConstOp,
									Src:   "m[\"c\"].Const",
									Value: "c",
								},
								{
									Line: 476,
									Op:   ir.FilterLtOp,
									Src:  "m[\"c\"].Value.Int() < runeSelf",
									Args: []ir.FilterExpr{
										{
											Line:  476,
											Op:    ir.FilterVarValueIntOp,
											Src:   "m[\"c\"].Value.Int()",
											Value: "c",
										},
										{
											Line:  476,
											Op:    ir.FilterIntOp,
											Src:   "runeSelf",
											Value: int64(128),
										},
									},
								},
							},
						},
					},
				},
			}},
		},
		{
			Line:        484,
			Name:        "sliceClear",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects slice clear loops, suggests an idiom that is recognized by the Go compiler",
			DocBefore:   "for i := 0; i < len(buf); i++ { buf[i] = 0 }",
			DocAfter:    "for i := range buf { buf[i] = 0 }",
			Rules: []ir.Rule{{
				Line:            485,
				SyntaxPatterns:  []ir.PatternString{{Line: 485, Value: "for $i := 0; $i < len($xs); $i++ { $xs[$i] = $zero }"}},
				ReportTemplate:  "for ... { ... } => for $i := range $xs { $xs[$i] = $zero }",
				SuggestTemplate: "for $i := range $xs { $xs[$i] = $zero }",
				WhereExpr: ir.FilterExpr{
					Line: 486,
					Op:   ir.FilterEqOp,
					Src:  "m[\"zero\"].Value.Int() == 0",
					Args: []ir.FilterExpr{
						{
							Line:  486,
							Op:    ir.FilterVarValueIntOp,
							Src:   "m[\"zero\"].Value.Int()",
							Value: "zero",
						},
						{
							Line:  486,
							Op:    ir.FilterIntOp,
							Src:   "0",
							Value: int64(0),
						},
					},
				},
			}},
		},
		{
			Line:        496,
			Name:        "utf8DecodeRune",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects expressions like []rune(s)[0] that may cause unwanted rune slice allocation",
			DocBefore:   "r := []rune(s)[0]",
			DocAfter:    "r, _ := utf8.DecodeRuneInString(s)",
			DocNote:     "See Go issue for details: https://github.com/golang/go/issues/45260",
			Rules: []ir.Rule{
				{
					Line:            503,
					SyntaxPatterns:  []ir.PatternString{{Line: 503, Value: "$ch := []rune($s)[0]"}},
					ReportTemplate:  "$$ => $ch, _ := utf8.DecodeRuneInString($ch)",
					SuggestTemplate: "$ch, _ := utf8.DecodeRuneInString($ch)",
					WhereExpr: ir.FilterExpr{
						Line: 504,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && m.File().Imports(`unicode/utf8`)",
						Args: []ir.FilterExpr{
							{
								Line:  504,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 504, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  504,
								Op:    ir.FilterFileImportsOp,
								Src:   "m.File().Imports(`unicode/utf8`)",
								Value: "unicode/utf8",
							},
						},
					},
				},
				{
					Line:            507,
					SyntaxPatterns:  []ir.PatternString{{Line: 507, Value: "$ch = []rune($s)[0]"}},
					ReportTemplate:  "$$ => $ch, _ = utf8.DecodeRuneInString($ch)",
					SuggestTemplate: "$ch, _ = utf8.DecodeRuneInString($ch)",
					WhereExpr: ir.FilterExpr{
						Line: 508,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && m.File().Imports(`unicode/utf8`)",
						Args: []ir.FilterExpr{
							{
								Line:  508,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 508, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  508,
								Op:    ir.FilterFileImportsOp,
								Src:   "m.File().Imports(`unicode/utf8`)",
								Value: "unicode/utf8",
							},
						},
					},
				},
				{
					Line:           513,
					SyntaxPatterns: []ir.PatternString{{Line: 513, Value: "[]rune($s)[0]"}},
					ReportTemplate: "use utf8.DecodeRuneInString($s) here",
					WhereExpr: ir.FilterExpr{
						Line: 514,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && !m.File().Imports(`unicode/utf8`)",
						Args: []ir.FilterExpr{
							{
								Line:  514,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 514, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line: 514,
								Op:   ir.FilterNotOp,
								Src:  "!m.File().Imports(`unicode/utf8`)",
								Args: []ir.FilterExpr{{
									Line:  514,
									Op:    ir.FilterFileImportsOp,
									Src:   "m.File().Imports(`unicode/utf8`)",
									Value: "unicode/utf8",
								}},
							},
						},
					},
				},
			},
		},
		{
			Line:        522,
			Name:        "fprint",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects fmt.Sprint(f/ln) calls which can be replaced with fmt.Fprint(f/ln)",
			DocBefore:   "w.Write([]byte(fmt.Sprintf(\"%x\", 10)))",
			DocAfter:    "fmt.Fprintf(w, \"%x\", 10)",
			Rules: []ir.Rule{
				{
					Line:            523,
					SyntaxPatterns:  []ir.PatternString{{Line: 523, Value: "$w.Write([]byte(fmt.Sprint($*args)))"}},
					ReportTemplate:  "$$ => fmt.Fprint($w, $args)",
					SuggestTemplate: "fmt.Fprint($w, $args)",
					WhereExpr: ir.FilterExpr{
						Line:  524,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
						Value: "w",
						Args:  []ir.FilterExpr{{Line: 524, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"}},
					},
				},
				{
					Line:            527,
					SyntaxPatterns:  []ir.PatternString{{Line: 527, Value: "$w.Write([]byte(fmt.Sprintf($*args)))"}},
					ReportTemplate:  "$$ => fmt.Fprintf($w, $args)",
					SuggestTemplate: "fmt.Fprintf($w, $args)",
					WhereExpr: ir.FilterExpr{
						Line:  528,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
						Value: "w",
						Args:  []ir.FilterExpr{{Line: 528, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"}},
					},
				},
				{
					Line:            531,
					SyntaxPatterns:  []ir.PatternString{{Line: 531, Value: "$w.Write([]byte(fmt.Sprintln($*args)))"}},
					ReportTemplate:  "$$ => fmt.Fprintln($w, $args)",
					SuggestTemplate: "fmt.Fprintln($w, $args)",
					WhereExpr: ir.FilterExpr{
						Line:  532,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
						Value: "w",
						Args:  []ir.FilterExpr{{Line: 532, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"}},
					},
				},
				{
					Line:            535,
					SyntaxPatterns:  []ir.PatternString{{Line: 535, Value: "io.WriteString($w, fmt.Sprint($*args))"}},
					ReportTemplate:  "$$ => fmt.Fprint($w, $args)",
					SuggestTemplate: "fmt.Fprint($w, $args)",
				},
				{
					Line:            538,
					SyntaxPatterns:  []ir.PatternString{{Line: 538, Value: "io.WriteString($w, fmt.Sprintf($*args))"}},
					ReportTemplate:  "$$ => fmt.Fprintf($w, $args)",
					SuggestTemplate: "fmt.Fprintf($w, $args)",
				},
				{
					Line:            541,
					SyntaxPatterns:  []ir.PatternString{{Line: 541, Value: "io.WriteString($w, fmt.Sprintln($*args))"}},
					ReportTemplate:  "$$ => fmt.Fprintln($w, $args)",
					SuggestTemplate: "fmt.Fprintln($w, $args)",
				},
			},
		},
		{
			Line:        549,
			Name:        "writeString",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects w.Write calls which can be replaced with w.WriteString",
			DocBefore:   "w.Write([]byte(\"foo\"))",
			DocAfter:    "w.WriteString(\"foo\")",
			Rules: []ir.Rule{{
				Line:            550,
				SyntaxPatterns:  []ir.PatternString{{Line: 550, Value: "$w.Write([]byte($s))"}},
				ReportTemplate:  "$$ => $w.WriteString($s)",
				SuggestTemplate: "$w.WriteString($s)",
				WhereExpr: ir.FilterExpr{
					Line: 551,
					Op:   ir.FilterAndOp,
					Src:  "m[\"w\"].Type.HasMethod(\"io.StringWriter.WriteString\") && m[\"s\"].Type.Is(`string`)",
					Args: []ir.FilterExpr{
						{
							Line:  551,
							Op:    ir.FilterVarTypeHasMethodOp,
							Src:   "m[\"w\"].Type.HasMethod(\"io.StringWriter.WriteString\")",
							Value: "w",
							Args:  []ir.FilterExpr{{Line: 551, Op: ir.FilterStringOp, Src: "\"io.StringWriter.WriteString\"", Value: "io.StringWriter.WriteString"}},
						},
						{
							Line:  551,
							Op:    ir.FilterVarTypeIsOp,
							Src:   "m[\"s\"].Type.Is(`string`)",
							Value: "s",
							Args:  []ir.FilterExpr{{Line: 551, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
						},
					},
				},
			}},
		},
		{
			Line:        559,
			Name:        "writeBytes",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects w.WriteString calls which can be replaced with w.Write",
			DocBefore:   "w.WriteString(buf.String())",
			DocAfter:    "w.Write(buf.Bytes())",
			Rules: []ir.Rule{
				{
					Line:            564,
					SyntaxPatterns:  []ir.PatternString{{Line: 564, Value: "io.WriteString($w, $buf.String())"}},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 565,
						Op:   ir.FilterOrOp,
						Src:  "isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							{
								Line:  565,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 561, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
							},
							{
								Line:  565,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 561, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
							},
						},
					},
				},
				{
					Line:            568,
					SyntaxPatterns:  []ir.PatternString{{Line: 568, Value: "io.WriteString($w, string($buf.Bytes()))"}},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 569,
						Op:   ir.FilterOrOp,
						Src:  "isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							{
								Line:  569,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 561, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
							},
							{
								Line:  569,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 561, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
							},
						},
					},
				},
				{
					Line:            572,
					SyntaxPatterns:  []ir.PatternString{{Line: 572, Value: "$w.WriteString($buf.String())"}},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 573,
						Op:   ir.FilterAndOp,
						Src:  "m[\"w\"].Type.HasMethod(\"io.Writer.Write\") && isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							{
								Line:  573,
								Op:    ir.FilterVarTypeHasMethodOp,
								Src:   "m[\"w\"].Type.HasMethod(\"io.Writer.Write\")",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 573, Op: ir.FilterStringOp, Src: "\"io.Writer.Write\"", Value: "io.Writer.Write"}},
							},
							{
								Line: 573,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  573,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 561, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  573,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 561, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
						},
					},
				},
				{
					Line:            576,
					SyntaxPatterns:  []ir.PatternString{{Line: 576, Value: "$w.WriteString(string($b))"}},
					ReportTemplate:  "$$ => $w.Write($b)",
					SuggestTemplate: "$w.Write($b)",
					WhereExpr: ir.FilterExpr{
						Line: 577,
						Op:   ir.FilterAndOp,
						Src:  "m[\"w\"].Type.HasMethod(\"io.Writer.Write\") && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line:  577,
								Op:    ir.FilterVarTypeHasMethodOp,
								Src:   "m[\"w\"].Type.HasMethod(\"io.Writer.Write\")",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 577, Op: ir.FilterStringOp, Src: "\"io.Writer.Write\"", Value: "io.Writer.Write"}},
							},
							{
								Line:  577,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 577, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        585,
			Name:        "bufferString",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects bytes.Buffer String() calls where Bytes() could be used instead",
			DocBefore:   "strings.Contains(buf.String(), string(b))",
			DocAfter:    "bytes.Contains(buf.Bytes(), b)",
			Rules: []ir.Rule{
				{
					Line:            590,
					SyntaxPatterns:  []ir.PatternString{{Line: 590, Value: "strings.$f($buf1.String(), $buf2.String())"}},
					ReportTemplate:  "$$ => bytes.$f($buf1.Bytes(), $buf2.Bytes())",
					SuggestTemplate: "bytes.$f($buf1.Bytes(), $buf2.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 592,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf1\"]) && isBuffer(m[\"buf2\"]) &&\n\tm[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`)",
						Args: []ir.FilterExpr{
							{
								Line: 592,
								Op:   ir.FilterAndOp,
								Src:  "isBuffer(m[\"buf1\"]) && isBuffer(m[\"buf2\"])",
								Args: []ir.FilterExpr{
									{
										Line: 592,
										Op:   ir.FilterOrOp,
										Src:  "isBuffer(m[\"buf1\"])",
										Args: []ir.FilterExpr{
											{
												Line:  592,
												Op:    ir.FilterVarTypeIsOp,
												Src:   "m[\"buf1\"].Type.Is(`bytes.Buffer`)",
												Value: "buf1",
												Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
											},
											{
												Line:  592,
												Op:    ir.FilterVarTypeIsOp,
												Src:   "m[\"buf1\"].Type.Is(`*bytes.Buffer`)",
												Value: "buf1",
												Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
											},
										},
									},
									{
										Line: 592,
										Op:   ir.FilterOrOp,
										Src:  "isBuffer(m[\"buf2\"])",
										Args: []ir.FilterExpr{
											{
												Line:  592,
												Op:    ir.FilterVarTypeIsOp,
												Src:   "m[\"buf2\"].Type.Is(`bytes.Buffer`)",
												Value: "buf2",
												Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
											},
											{
												Line:  592,
												Op:    ir.FilterVarTypeIsOp,
												Src:   "m[\"buf2\"].Type.Is(`*bytes.Buffer`)",
												Value: "buf2",
												Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
											},
										},
									},
								},
							},
							{
								Line:  593,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"f\"].Text.Matches(`Compare|Contains|HasPrefix|HasSuffix|EqualFold`)",
								Value: "f",
								Args:  []ir.FilterExpr{{Line: 593, Op: ir.FilterStringOp, Src: "`Compare|Contains|HasPrefix|HasSuffix|EqualFold`", Value: "Compare|Contains|HasPrefix|HasSuffix|EqualFold"}},
							},
						},
					},
				},
				{
					Line:            597,
					SyntaxPatterns:  []ir.PatternString{{Line: 597, Value: "strings.Contains($buf.String(), string($b))"}},
					ReportTemplate:  "$$ => bytes.Contains($buf.Bytes(), $b)",
					SuggestTemplate: "bytes.Contains($buf.Bytes(), $b)",
					WhereExpr: ir.FilterExpr{
						Line: 598,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 598,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  598,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  598,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  598,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 598, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            600,
					SyntaxPatterns:  []ir.PatternString{{Line: 600, Value: "strings.HasPrefix($buf.String(), string($b))"}},
					ReportTemplate:  "$$ => bytes.HasPrefix($buf.Bytes(), $b)",
					SuggestTemplate: "bytes.HasPrefix($buf.Bytes(), $b)",
					WhereExpr: ir.FilterExpr{
						Line: 601,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 601,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  601,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  601,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  601,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 601, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            603,
					SyntaxPatterns:  []ir.PatternString{{Line: 603, Value: "strings.HasSuffix($buf.String(), string($b))"}},
					ReportTemplate:  "$$ => bytes.HasSuffix($buf.Bytes(), $b)",
					SuggestTemplate: "bytes.HasSuffix($buf.Bytes(), $b)",
					WhereExpr: ir.FilterExpr{
						Line: 604,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 604,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  604,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  604,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  604,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 604, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            606,
					SyntaxPatterns:  []ir.PatternString{{Line: 606, Value: "strings.Count($buf.String(), string($b))"}},
					ReportTemplate:  "$$ => bytes.Count($buf.Bytes(), $b)",
					SuggestTemplate: "bytes.Count($buf.Bytes(), $b)",
					WhereExpr: ir.FilterExpr{
						Line: 607,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 607,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  607,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  607,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  607,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 607, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            609,
					SyntaxPatterns:  []ir.PatternString{{Line: 609, Value: "strings.Index($buf.String(), string($b))"}},
					ReportTemplate:  "$$ => bytes.Index($buf.Bytes(), $b)",
					SuggestTemplate: "bytes.Index($buf.Bytes(), $b)",
					WhereExpr: ir.FilterExpr{
						Line: 610,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 610,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  610,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  610,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  610,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 610, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            612,
					SyntaxPatterns:  []ir.PatternString{{Line: 612, Value: "strings.EqualFold($buf.String(), string($b))"}},
					ReportTemplate:  "$$ => bytes.EqualFold($buf.Bytes(), $b)",
					SuggestTemplate: "bytes.EqualFold($buf.Bytes(), $b)",
					WhereExpr: ir.FilterExpr{
						Line: 613,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 613,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  613,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  613,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  613,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 613, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            616,
					SyntaxPatterns:  []ir.PatternString{{Line: 616, Value: "strings.Contains($buf.String(), $s)"}},
					ReportTemplate:  "$$ => bytes.Contains($buf.Bytes(), []byte($s))",
					SuggestTemplate: "bytes.Contains($buf.Bytes(), []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 617,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 617,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  617,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  617,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  617,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 617, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            619,
					SyntaxPatterns:  []ir.PatternString{{Line: 619, Value: "strings.HasPrefix($buf.String(), $s)"}},
					ReportTemplate:  "$$ => bytes.HasPrefix($buf.Bytes(), []byte($s))",
					SuggestTemplate: "bytes.HasPrefix($buf.Bytes(), []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 620,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 620,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  620,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  620,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  620,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 620, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            622,
					SyntaxPatterns:  []ir.PatternString{{Line: 622, Value: "strings.HasSuffix($buf.String(), $s)"}},
					ReportTemplate:  "$$ => bytes.HasSuffix($buf.Bytes(), []byte($s))",
					SuggestTemplate: "bytes.HasSuffix($buf.Bytes(), []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 623,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 623,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  623,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  623,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  623,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 623, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            625,
					SyntaxPatterns:  []ir.PatternString{{Line: 625, Value: "strings.Count($buf.String(), $s)"}},
					ReportTemplate:  "$$ => bytes.Count($buf.Bytes(), []byte($s))",
					SuggestTemplate: "bytes.Count($buf.Bytes(), []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 626,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 626,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  626,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  626,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  626,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 626, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            628,
					SyntaxPatterns:  []ir.PatternString{{Line: 628, Value: "strings.Index($buf.String(), $s)"}},
					ReportTemplate:  "$$ => bytes.Index($buf.Bytes(), []byte($s))",
					SuggestTemplate: "bytes.Index($buf.Bytes(), []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 629,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 629,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  629,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  629,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  629,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 629, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            631,
					SyntaxPatterns:  []ir.PatternString{{Line: 631, Value: "strings.EqualFold($buf.String(), $s)"}},
					ReportTemplate:  "$$ => bytes.EqualFold($buf.Bytes(), []byte($s))",
					SuggestTemplate: "bytes.EqualFold($buf.Bytes(), []byte($s))",
					WhereExpr: ir.FilterExpr{
						Line: 632,
						Op:   ir.FilterAndOp,
						Src:  "isBuffer(m[\"buf\"]) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line: 632,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									{
										Line:  632,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
									},
									{
										Line:  632,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
									},
								},
							},
							{
								Line:  632,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 632, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            635,
					SyntaxPatterns:  []ir.PatternString{{Line: 635, Value: "[]byte($buf.String())"}},
					ReportTemplate:  "$$ => $buf.Bytes()",
					SuggestTemplate: "$buf.Bytes()",
					WhereExpr: ir.FilterExpr{
						Line: 635,
						Op:   ir.FilterOrOp,
						Src:  "isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							{
								Line:  635,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
							},
							{
								Line:  635,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
							},
						},
					},
				},
				{
					Line: 637,
					SyntaxPatterns: []ir.PatternString{
						{Line: 637, Value: "fmt.Fprint($w, $buf.String())"},
						{Line: 637, Value: "fmt.Fprintf($w, \"%s\", $buf.String())"},
						{Line: 637, Value: "fmt.Fprintf($w, \"%v\", $buf.String())"},
					},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 638,
						Op:   ir.FilterOrOp,
						Src:  "isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							{
								Line:  638,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"}},
							},
							{
								Line:  638,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
								Value: "buf",
								Args:  []ir.FilterExpr{{Line: 587, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        644,
			Name:        "rangeExprCopy",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects array range loops that result in an excessive full data copy",
			Rules: []ir.Rule{
				{
					Line: 645,
					SyntaxPatterns: []ir.PatternString{
						{Line: 645, Value: "for $_, $_ := range $e"},
						{Line: 645, Value: "for $_, $_ = range $e"},
					},
					ReportTemplate:  "$e => &$e",
					SuggestTemplate: "&$e",
					WhereExpr: ir.FilterExpr{
						Line: 646,
						Op:   ir.FilterAndOp,
						Src:  "m[\"e\"].Addressable && m[\"e\"].Type.Is(`[$_]$_`) && m[\"e\"].Type.Size > 2048",
						Args: []ir.FilterExpr{
							{
								Line: 646,
								Op:   ir.FilterAndOp,
								Src:  "m[\"e\"].Addressable && m[\"e\"].Type.Is(`[$_]$_`)",
								Args: []ir.FilterExpr{
									{
										Line:  646,
										Op:    ir.FilterVarAddressableOp,
										Src:   "m[\"e\"].Addressable",
										Value: "e",
									},
									{
										Line:  646,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"e\"].Type.Is(`[$_]$_`)",
										Value: "e",
										Args:  []ir.FilterExpr{{Line: 646, Op: ir.FilterStringOp, Src: "`[$_]$_`", Value: "[$_]$_"}},
									},
								},
							},
							{
								Line: 646,
								Op:   ir.FilterGtOp,
								Src:  "m[\"e\"].Type.Size > 2048",
								Args: []ir.FilterExpr{
									{
										Line:  646,
										Op:    ir.FilterVarTypeSizeOp,
										Src:   "m[\"e\"].Type.Size",
										Value: "e",
									},
									{
										Line:  646,
										Op:    ir.FilterIntOp,
										Src:   "2048",
										Value: int64(2048),
									},
								},
							},
						},
					},
					LocationVar: "e",
				},
				{
					Line: 652,
					SyntaxPatterns: []ir.PatternString{
						{Line: 652, Value: "for $_, $_ := range $e"},
						{Line: 652, Value: "for $_, $_ = range $e"},
					},
					ReportTemplate: "range over big array value expression is ineffective",
					WhereExpr: ir.FilterExpr{
						Line: 653,
						Op:   ir.FilterAndOp,
						Src:  "m[\"e\"].Type.Is(`[$_]$_`) && m[\"e\"].Type.Size > 2048",
						Args: []ir.FilterExpr{
							{
								Line:  653,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"e\"].Type.Is(`[$_]$_`)",
								Value: "e",
								Args:  []ir.FilterExpr{{Line: 653, Op: ir.FilterStringOp, Src: "`[$_]$_`", Value: "[$_]$_"}},
							},
							{
								Line: 653,
								Op:   ir.FilterGtOp,
								Src:  "m[\"e\"].Type.Size > 2048",
								Args: []ir.FilterExpr{
									{
										Line:  653,
										Op:    ir.FilterVarTypeSizeOp,
										Src:   "m[\"e\"].Type.Size",
										Value: "e",
									},
									{
										Line:  653,
										Op:    ir.FilterIntOp,
										Src:   "2048",
										Value: int64(2048),
									},
								},
							},
						},
					},
					LocationVar: "e",
				},
			},
		},
		{
			Line:        660,
			Name:        "rangeToAppend",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects range loops that can be turned into a single append call",
			Rules: []ir.Rule{{
				Line:            661,
				SyntaxPatterns:  []ir.PatternString{{Line: 661, Value: "for $_, $x := range $src { $dst = append($dst, $x) }"}},
				ReportTemplate:  "for ... { ... } => $dst = append($dst, $src...)",
				SuggestTemplate: "$dst = append($dst, $src...)",
				WhereExpr: ir.FilterExpr{
					Line:  662,
					Op:    ir.FilterVarTypeIsOp,
					Src:   "m[\"src\"].Type.Is(`[]$_`)",
					Value: "src",
					Args:  []ir.FilterExpr{{Line: 662, Op: ir.FilterStringOp, Src: "`[]$_`", Value: "[]$_"}},
				},
			}},
		},
		{
			Line:        669,
			Name:        "rangeToCopy",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects range loops that can be turned into a single copy call",
			Rules: []ir.Rule{{
				Line: 670,
				SyntaxPatterns: []ir.PatternString{
					{Line: 671, Value: "for $i := range $src { $dst[$i] = $src[$i] }"},
					{Line: 672, Value: "for $i, $x := range $src { $dst[$i] = $x }"},
					{Line: 673, Value: "for $i := 0; $i < len($src); $i++ { $dst[$i] = $src[$i] }"},
				},
				ReportTemplate:  "for ... { ... } => copy($dst, $src)",
				SuggestTemplate: "copy($dst, $src)",
				WhereExpr: ir.FilterExpr{
					Line:  674,
					Op:    ir.FilterVarTypeIsOp,
					Src:   "m[\"src\"].Type.Is(`[]$_`)",
					Value: "src",
					Args:  []ir.FilterExpr{{Line: 674, Op: ir.FilterStringOp, Src: "`[]$_`", Value: "[]$_"}},
				},
			}},
		},
		{
			Line:        681,
			Name:        "sliceSelfCopy",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects loops where slice dst=src and they can be replaced with a copy call",
			Rules: []ir.Rule{{
				Line:            682,
				SyntaxPatterns:  []ir.PatternString{{Line: 683, Value: "for $i := 0; i < $n; $i++ { $s[$i] = $s[$offset+$i] }"}},
				ReportTemplate:  "for ... { ... } => copy($s[:$n], $s[$offset:])",
				SuggestTemplate: "copy($s[:$n], $s[$offset:])",
				WhereExpr: ir.FilterExpr{
					Line:  684,
					Op:    ir.FilterVarTypeIsOp,
					Src:   "m[\"s\"].Type.Is(`[]$_`)",
					Value: "s",
					Args:  []ir.FilterExpr{{Line: 684, Op: ir.FilterStringOp, Src: "`[]$_`", Value: "[]$_"}},
				},
			}},
		},
		{
			Line:        691,
			Name:        "rangeRuneSlice",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects a range over []rune(string) where copying to a new slice is redundant",
			Rules: []ir.Rule{
				{
					Line:            692,
					SyntaxPatterns:  []ir.PatternString{{Line: 692, Value: "for _, $r := range []rune($s)"}},
					ReportTemplate:  "$$ => for _, $r := range $s",
					SuggestTemplate: "for _, $r := range $s",
					WhereExpr: ir.FilterExpr{
						Line:  693,
						Op:    ir.FilterVarTypeUnderlyingIsOp,
						Src:   "m[\"s\"].Type.Underlying().Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 693, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line:            696,
					SyntaxPatterns:  []ir.PatternString{{Line: 696, Value: "for _, $r = range []rune($s)"}},
					ReportTemplate:  "$$ => for _, $r = range $s",
					SuggestTemplate: "for _, $r = range $s",
					WhereExpr: ir.FilterExpr{
						Line:  697,
						Op:    ir.FilterVarTypeUnderlyingIsOp,
						Src:   "m[\"s\"].Type.Underlying().Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 697, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line:            700,
					SyntaxPatterns:  []ir.PatternString{{Line: 700, Value: "for range []rune($s)"}},
					ReportTemplate:  "$$ => for range $s",
					SuggestTemplate: "for range $s",
					WhereExpr: ir.FilterExpr{
						Line:  701,
						Op:    ir.FilterVarTypeUnderlyingIsOp,
						Src:   "m[\"s\"].Type.Underlying().Is(`string`)",
						Value: "s",
						Args:  []ir.FilterExpr{{Line: 701, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
					},
				},
				{
					Line:            704,
					SyntaxPatterns:  []ir.PatternString{{Line: 704, Value: "for _, $r := range string($runes)"}},
					ReportTemplate:  "$$ => for _, $r := range $runes",
					SuggestTemplate: "for _, $r := range $runes",
					WhereExpr: ir.FilterExpr{
						Line:  705,
						Op:    ir.FilterVarTypeUnderlyingIsOp,
						Src:   "m[\"runes\"].Type.Underlying().Is(`[]rune`)",
						Value: "runes",
						Args:  []ir.FilterExpr{{Line: 705, Op: ir.FilterStringOp, Src: "`[]rune`", Value: "[]rune"}},
					},
				},
				{
					Line:            708,
					SyntaxPatterns:  []ir.PatternString{{Line: 708, Value: "for _, $r = range string($runes)"}},
					ReportTemplate:  "$$ => for _, $r = range $runes",
					SuggestTemplate: "for _, $r = range $runes",
					WhereExpr: ir.FilterExpr{
						Line:  709,
						Op:    ir.FilterVarTypeUnderlyingIsOp,
						Src:   "m[\"runes\"].Type.Underlying().Is(`[]rune`)",
						Value: "runes",
						Args:  []ir.FilterExpr{{Line: 709, Op: ir.FilterStringOp, Src: "`[]rune`", Value: "[]rune"}},
					},
				},
			},
		},
		{
			Line:        715,
			Name:        "reflectDeepEqual",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects usages of reflect.DeepEqual that can be rewritten",
			Rules: []ir.Rule{
				{
					Line:            716,
					SyntaxPatterns:  []ir.PatternString{{Line: 716, Value: "reflect.DeepEqual($x, $y)"}},
					ReportTemplate:  "$$ => bytes.Equal($x, $y)",
					SuggestTemplate: "bytes.Equal($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 717,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`[]byte`) && m[\"y\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line:  717,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`[]byte`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 717, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
							{
								Line:  717,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`[]byte`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 717, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            724,
					SyntaxPatterns:  []ir.PatternString{{Line: 724, Value: "reflect.DeepEqual($x, $y)"}},
					ReportTemplate:  "$$ => ($x == $y)",
					SuggestTemplate: "($x == $y)",
					WhereExpr: ir.FilterExpr{
						Line: 725,
						Op:   ir.FilterOrOp,
						Src:  "(m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)) ||\n\t(m[\"x\"].Type.OfKind(`numeric`) && m[\"y\"].Type.OfKind(`numeric`))",
						Args: []ir.FilterExpr{
							{
								Line: 725,
								Op:   ir.FilterAndOp,
								Src:  "(m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`))",
								Args: []ir.FilterExpr{
									{
										Line:  725,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"x\"].Type.Is(`string`)",
										Value: "x",
										Args:  []ir.FilterExpr{{Line: 725, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
									},
									{
										Line:  725,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"y\"].Type.Is(`string`)",
										Value: "y",
										Args:  []ir.FilterExpr{{Line: 725, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
									},
								},
							},
							{
								Line: 726,
								Op:   ir.FilterAndOp,
								Src:  "(m[\"x\"].Type.OfKind(`numeric`) && m[\"y\"].Type.OfKind(`numeric`))",
								Args: []ir.FilterExpr{
									{
										Line:  726,
										Op:    ir.FilterVarTypeOfKindOp,
										Src:   "m[\"x\"].Type.OfKind(`numeric`)",
										Value: "x",
										Args:  []ir.FilterExpr{{Line: 726, Op: ir.FilterStringOp, Src: "`numeric`", Value: "numeric"}},
									},
									{
										Line:  726,
										Op:    ir.FilterVarTypeOfKindOp,
										Src:   "m[\"y\"].Type.OfKind(`numeric`)",
										Value: "y",
										Args:  []ir.FilterExpr{{Line: 726, Op: ir.FilterStringOp, Src: "`numeric`", Value: "numeric"}},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			Line:        732,
			Name:        "reflectType",
			MatcherName: "m",
			DocTags:     []string{"o1", "score1"},
			DocSummary:  "Detects reflect Type() related patterns that can be optimized",
			Rules: []ir.Rule{
				{
					Line:            733,
					SyntaxPatterns:  []ir.PatternString{{Line: 733, Value: "reflect.ValueOf($x).Type()"}},
					ReportTemplate:  "$$ => reflect.TypeOf($x)",
					SuggestTemplate: "reflect.TypeOf($x)",
				},
				{
					Line:            735,
					SyntaxPatterns:  []ir.PatternString{{Line: 735, Value: "reflect.TypeOf($x.Interface())"}},
					ReportTemplate:  "$$ => $x.Type()",
					SuggestTemplate: "$x.Type()",
					WhereExpr: ir.FilterExpr{
						Line:  736,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`reflect.Value`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 736, Op: ir.FilterStringOp, Src: "`reflect.Value`", Value: "reflect.Value"}},
					},
				},
				{
					Line:            739,
					SyntaxPatterns:  []ir.PatternString{{Line: 739, Value: "fmt.Sprintf(\"%T\", $x.Interface())"}},
					ReportTemplate:  "$$ => $x.Type().String()",
					SuggestTemplate: "$x.Type().String()",
					WhereExpr: ir.FilterExpr{
						Line:  740,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`reflect.Value`)",
						Value: "x",
						Args:  []ir.FilterExpr{{Line: 740, Op: ir.FilterStringOp, Src: "`reflect.Value`", Value: "reflect.Value"}},
					},
				},
				{
					Line:            742,
					SyntaxPatterns:  []ir.PatternString{{Line: 742, Value: "fmt.Sprintf(\"%T\", $x)"}},
					ReportTemplate:  "$$ => reflect.TypeOf($x).String()",
					SuggestTemplate: "reflect.TypeOf($x).String()",
				},
			},
		},
		{
			Line:        748,
			Name:        "binaryWrite",
			MatcherName: "m",
			DocTags:     []string{"o1", "score3"},
			DocSummary:  "Detects binary.Write uses that can be optimized",
			Rules: []ir.Rule{
				{
					Line:            749,
					SyntaxPatterns:  []ir.PatternString{{Line: 749, Value: "$err := binary.Write($w, $_, $b)"}},
					ReportTemplate:  "$$ => _, $err := $w.Write($b)",
					SuggestTemplate: "_, $err := $w.Write($b)",
					WhereExpr: ir.FilterExpr{
						Line:  750,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"b\"].Type.Is(`[]byte`)",
						Value: "b",
						Args:  []ir.FilterExpr{{Line: 750, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
					},
				},
				{
					Line:            753,
					SyntaxPatterns:  []ir.PatternString{{Line: 753, Value: "binary.Write($w, $_, $b)"}},
					ReportTemplate:  "$$ => $w.Write($b)",
					SuggestTemplate: "$w.Write($b)",
					WhereExpr: ir.FilterExpr{
						Line: 754,
						Op:   ir.FilterAndOp,
						Src:  "m[\"$$\"].Node.Parent().Is(`ExprStmt`) && m[\"b\"].Type.Is(`[]byte`)",
						Args: []ir.FilterExpr{
							{
								Line: 754,
								Op:   ir.FilterRootNodeParentIsOp,
								Src:  "m[\"$$\"].Node.Parent().Is(`ExprStmt`)",
								Args: []ir.FilterExpr{{Line: 754, Op: ir.FilterStringOp, Src: "`ExprStmt`", Value: "ExprStmt"}},
							},
							{
								Line:  754,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"b\"].Type.Is(`[]byte`)",
								Value: "b",
								Args:  []ir.FilterExpr{{Line: 754, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"}},
							},
						},
					},
				},
				{
					Line:            757,
					SyntaxPatterns:  []ir.PatternString{{Line: 757, Value: "$err := binary.Write($w, $_, $s)"}},
					ReportTemplate:  "$$ => _, $err := $w.WriteString($s)",
					SuggestTemplate: "_, $err := $w.WriteString($s)",
					WhereExpr: ir.FilterExpr{
						Line: 758,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && m[\"w\"].Type.HasMethod(`io.StringWriter.WriteString`)",
						Args: []ir.FilterExpr{
							{
								Line:  758,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args:  []ir.FilterExpr{{Line: 758, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  758,
								Op:    ir.FilterVarTypeHasMethodOp,
								Src:   "m[\"w\"].Type.HasMethod(`io.StringWriter.WriteString`)",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 758, Op: ir.FilterStringOp, Src: "`io.StringWriter.WriteString`", Value: "io.StringWriter.WriteString"}},
							},
						},
					},
				},
				{
					Line:            761,
					SyntaxPatterns:  []ir.PatternString{{Line: 761, Value: "binary.Write($w, $_, $s)"}},
					ReportTemplate:  "$$ => $w.WriteString($s)",
					SuggestTemplate: "$w.WriteString($s)",
					WhereExpr: ir.FilterExpr{
						Line: 762,
						Op:   ir.FilterAndOp,
						Src:  "m[\"$$\"].Node.Parent().Is(`ExprStmt`) && m[\"s\"].Type.Is(`string`) && m[\"w\"].Type.HasMethod(`io.StringWriter.WriteString`)",
						Args: []ir.FilterExpr{
							{
								Line: 762,
								Op:   ir.FilterAndOp,
								Src:  "m[\"$$\"].Node.Parent().Is(`ExprStmt`) && m[\"s\"].Type.Is(`string`)",
								Args: []ir.FilterExpr{
									{
										Line: 762,
										Op:   ir.FilterRootNodeParentIsOp,
										Src:  "m[\"$$\"].Node.Parent().Is(`ExprStmt`)",
										Args: []ir.FilterExpr{{Line: 762, Op: ir.FilterStringOp, Src: "`ExprStmt`", Value: "ExprStmt"}},
									},
									{
										Line:  762,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"s\"].Type.Is(`string`)",
										Value: "s",
										Args:  []ir.FilterExpr{{Line: 762, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
									},
								},
							},
							{
								Line:  762,
								Op:    ir.FilterVarTypeHasMethodOp,
								Src:   "m[\"w\"].Type.HasMethod(`io.StringWriter.WriteString`)",
								Value: "w",
								Args:  []ir.FilterExpr{{Line: 762, Op: ir.FilterStringOp, Src: "`io.StringWriter.WriteString`", Value: "io.StringWriter.WriteString"}},
							},
						},
					},
				},
			},
		},
	},
}

