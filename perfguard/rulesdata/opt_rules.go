// Code generated by "precompile.go". DO NOT EDIT.

package rulesdata

import "github.com/quasilyte/go-ruleguard/ruleguard/ir"

var Opt = &ir.File{
	PkgPath:       "gorules",
	CustomDecls:   []string{},
	BundleImports: []ir.BundleImport{},
	RuleGroups: []ir.RuleGroup{
		{
			Line:        9,
			Name:        "regexpCompile",
			MatcherName: "m",
			DocTags:     []string{"o1", "score4"},
			DocSummary:  "Detects regexp compilation on hot execution paths",
			Rules: []ir.Rule{{
				Line: 14,
				SyntaxPatterns: []ir.PatternString{
					{Line: 16, Value: "regexp.Compile($*_)"},
					{Line: 17, Value: "regexp.MustCompile($*_)"},
					{Line: 18, Value: "regexp.CompilePOSIX($*_)"},
					{Line: 19, Value: "regexp.MustCompilePOSIX($*_)"},
					{Line: 21, Value: "regexp.Match($*_)"},
					{Line: 22, Value: "regexp.MatchString($*_)"},
					{Line: 23, Value: "regexp.MatchReader($*_)"},
				},
				ReportTemplate: "regexp compilation should be avoided on the hot paths",
			}},
		},
		{
			Line:        29,
			Name:        "sprintConcat2",
			MatcherName: "m",
			DocTags:     []string{"o2", "score2"},
			DocSummary:  "Detects sprint calls that can be rewritten as a string concat",
			Rules: []ir.Rule{
				{
					Line:            34,
					SyntaxPatterns:  []ir.PatternString{{Line: 34, Value: "fmt.Sprintf(\"%s=%s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x + \"=\" + $y",
					SuggestTemplate: "$x + \"=\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 35,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  35,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 35, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  35,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 35, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            38,
					SyntaxPatterns:  []ir.PatternString{{Line: 38, Value: "fmt.Sprintf(\"%s.%s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x + \".\" + $y",
					SuggestTemplate: "$x + \".\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 39,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  39,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 39, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  39,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 39, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            42,
					SyntaxPatterns:  []ir.PatternString{{Line: 42, Value: "fmt.Sprintf(\"%s/%s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x + \"/\" + $y",
					SuggestTemplate: "$x + \"/\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 43,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  43,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 43, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  43,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 43, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            46,
					SyntaxPatterns:  []ir.PatternString{{Line: 46, Value: "fmt.Sprintf(\"%s:%s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x + \":\" + $y",
					SuggestTemplate: "$x + \":\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 47,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  47,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 47, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  47,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 47, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
				{
					Line:            50,
					SyntaxPatterns:  []ir.PatternString{{Line: 50, Value: "fmt.Sprintf(\"%s: %s\", $x, $y)"}},
					ReportTemplate:  "$$ => $x + \": \" + $y",
					SuggestTemplate: "$x + \": \" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 51,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							{
								Line:  51,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 51, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
							{
								Line:  51,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args:  []ir.FilterExpr{{Line: 51, Op: ir.FilterStringOp, Src: "`string`", Value: "string"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        57,
			Name:        "rangeValueCopy",
			MatcherName: "m",
			DocTags:     []string{"o1", "score2"},
			DocSummary:  "Detects range loops that copy large value on every iteration",
			Rules: []ir.Rule{{
				Line: 58,
				SyntaxPatterns: []ir.PatternString{
					{Line: 58, Value: "for $_, $v := range $_ { $*_ }"},
					{Line: 58, Value: "for $_, $v = range $_ { $*_ }"},
				},
				ReportTemplate: "every iteration copies a large object into $v",
				WhereExpr: ir.FilterExpr{
					Line: 59,
					Op:   ir.FilterGtOp,
					Src:  "m[\"v\"].Type.Size > 128",
					Args: []ir.FilterExpr{
						{
							Line:  59,
							Op:    ir.FilterVarTypeSizeOp,
							Src:   "m[\"v\"].Type.Size",
							Value: "v",
						},
						{
							Line:  59,
							Op:    ir.FilterIntOp,
							Src:   "128",
							Value: int64(128),
						},
					},
				},
			}},
		},
	},
}

