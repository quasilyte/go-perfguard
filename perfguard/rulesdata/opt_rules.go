// Code generated by "precompile.go". DO NOT EDIT.

package rulesdata

import "github.com/quasilyte/go-ruleguard/ruleguard/ir"

var Opt = &ir.File{
	PkgPath:       "gorules",
	CustomDecls:   []string{},
	BundleImports: []ir.BundleImport{},
	RuleGroups: []ir.RuleGroup{
		ir.RuleGroup{
			Line:        9,
			Name:        "regexpCompile",
			MatcherName: "m",
			DocTags: []string{
				"o1",
				"score4",
			},
			DocSummary: "Detects regexp compilation on hot execution paths",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 14,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 16, Value: "regexp.Compile($*_)"},
						ir.PatternString{Line: 17, Value: "regexp.MustCompile($*_)"},
						ir.PatternString{Line: 18, Value: "regexp.CompilePOSIX($*_)"},
						ir.PatternString{Line: 19, Value: "regexp.MustCompilePOSIX($*_)"},
						ir.PatternString{Line: 21, Value: "regexp.Match($*_)"},
						ir.PatternString{Line: 22, Value: "regexp.MatchString($*_)"},
						ir.PatternString{Line: 23, Value: "regexp.MatchReader($*_)"},
					},
					ReportTemplate: "regexp compilation should be avoided on the hot paths",
				},
			},
		},
		ir.RuleGroup{
			Line:        29,
			Name:        "sprintConcat2",
			MatcherName: "m",
			DocTags: []string{
				"o2",
				"score2",
			},
			DocSummary: "Detects sprint calls that can be rewritten as a string concat",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 34,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 34, Value: "fmt.Sprintf(\"%s=%s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x + \"=\" + $y",
					SuggestTemplate: "$x + \"=\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 35,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  35,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 35, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  35,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 35, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 38,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 38, Value: "fmt.Sprintf(\"%s.%s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x + \".\" + $y",
					SuggestTemplate: "$x + \".\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 39,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  39,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 39, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  39,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 39, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 42,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 42, Value: "fmt.Sprintf(\"%s/%s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x + \"/\" + $y",
					SuggestTemplate: "$x + \"/\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 43,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  43,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 43, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  43,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 43, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 46,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 46, Value: "fmt.Sprintf(\"%s:%s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x + \":\" + $y",
					SuggestTemplate: "$x + \":\" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 47,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  47,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 47, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  47,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 47, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 50,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 50, Value: "fmt.Sprintf(\"%s: %s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x + \": \" + $y",
					SuggestTemplate: "$x + \": \" + $y",
					WhereExpr: ir.FilterExpr{
						Line: 51,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  51,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 51, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  51,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 51, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        57,
			Name:        "rangeValueCopy",
			MatcherName: "m",
			DocTags: []string{
				"o1",
				"score2",
			},
			DocSummary: "Detects range loops that copy large value on every iteration",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 58,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 58, Value: "for $_, $v := range $_ { $*_ }"},
						ir.PatternString{Line: 58, Value: "for $_, $v = range $_ { $*_ }"},
					},
					ReportTemplate: "every iteration copies a large object into $v",
					WhereExpr: ir.FilterExpr{
						Line: 59,
						Op:   ir.FilterGtOp,
						Src:  "m[\"v\"].Type.Size > 128",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  59,
								Op:    ir.FilterVarTypeSizeOp,
								Src:   "m[\"v\"].Type.Size",
								Value: "v",
							},
							ir.FilterExpr{
								Line:  59,
								Op:    ir.FilterIntOp,
								Src:   "128",
								Value: int64(128),
							},
						},
					},
				},
			},
		},
	},
}

